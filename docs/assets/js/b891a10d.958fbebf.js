"use strict";(self.webpackChunkclickhouse=self.webpackChunkclickhouse||[]).push([[52817],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return d}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(t),d=a,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||o;return t?r.createElement(h,i(i({ref:n},p),{},{components:t})):r.createElement(h,i({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},44837:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var r=t(87462),a=t(63366),o=(t(67294),t(3905)),i=["components"],l={sidebar_label:"Database/SQL API",sidebar_position:4,keywords:["clickhouse","go","client","high-level","api","database","sql"],slug:"/en/integrations/go/clickhouse-go/database-sql-api",description:"Database/SQL API"},s="Database/SQL API",c={unversionedId:"en/integrations/language-clients/go/clickhouse-go/database-sql-api",id:"en/integrations/language-clients/go/clickhouse-go/database-sql-api",title:"Database/SQL API",description:"Database/SQL API",source:"@site/docs/en/integrations/language-clients/go/clickhouse-go/database-sql-api.md",sourceDirName:"en/integrations/language-clients/go/clickhouse-go",slug:"/en/integrations/go/clickhouse-go/database-sql-api",permalink:"/docs/en/integrations/go/clickhouse-go/database-sql-api",draft:!1,editUrl:"https://github.com/ClickHouse/clickhouse-docs/blob/main/docs/en/integrations/language-clients/go/clickhouse-go/database-sql-api.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"Database/SQL API",sidebar_position:4,keywords:["clickhouse","go","client","high-level","api","database","sql"],slug:"/en/integrations/go/clickhouse-go/database-sql-api",description:"Database/SQL API"},sidebar:"english",previous:{title:"ClickHouse Client API",permalink:"/docs/en/integrations/go/clickhouse-go/clickhouse-api"},next:{title:"Performance Tips",permalink:"/docs/en/integrations/go/clickhouse-go/performance-tips"}},p={},u=[{value:"Connecting",id:"connecting",level:2},{value:"Connection Settings",id:"connection-settings",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Connecting over HTTP",id:"connecting-over-http",level:3},{value:"Connecting to Multiple Nodes",id:"connecting-to-multiple-nodes",level:3},{value:"Using TLS",id:"using-tls",level:2},{value:"Authentication",id:"authentication",level:2},{value:"Execution",id:"execution",level:2},{value:"Batch Insert",id:"batch-insert",level:2},{value:"Querying Row/s",id:"querying-rows",level:2},{value:"Async Insert",id:"async-insert",level:2},{value:"Columnar Insert",id:"columnar-insert",level:2},{value:"Using Structs",id:"using-structs",level:2},{value:"Type Conversions",id:"type-conversions",level:2},{value:"Complex Types",id:"complex-types",level:2},{value:"Maps",id:"maps",level:3},{value:"JSON",id:"json",level:3},{value:"Compression",id:"compression",level:2},{value:"Parameter Binding",id:"parameter-binding",level:2},{value:"Using Context",id:"using-context",level:2},{value:"Sessions",id:"sessions",level:2},{value:"Dynamic Scanning",id:"dynamic-scanning",level:2},{value:"External Tables",id:"external-tables",level:2},{value:"Open Telemetry",id:"open-telemetry",level:2}],m={toc:u};function d(e){var n=e.components,t=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"databasesql-api"},"Database/SQL API"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"database/sql")," or \u201cstandard\u201d API allows users to use the client in scenarios where application code should be agnostic of the underlying databases by conforming to a standard interface. This comes at some expense - additional layers of abstraction and indirection and primitives which are not necessarily aligned with ClickHouse. These costs are, however, typically acceptable in scenarios where tooling needs to connect to multiple databases."),(0,o.kt)("p",null,"Additionally, this client supports using HTTP as the transport layer - data will still be encoded in the native format for optimal performance."),(0,o.kt)("p",null,"The following aims to mirror the structure of the documentation for the ClickHouse API."),(0,o.kt)("p",null,"Full code examples for the standard API can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/tree/main/examples/std"},"here"),"."),(0,o.kt)("h2",{id:"connecting"},"Connecting"),(0,o.kt)("p",null,"Connection can be achieved either via a DSN string with the format ",(0,o.kt)("inlineCode",{parentName:"p"},"clickhouse://<host>:<port>?<query_option>=<value>")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Open")," method or via the ",(0,o.kt)("inlineCode",{parentName:"p"},"clickhouse.OpenDB")," method. The latter is not part of the ",(0,o.kt)("inlineCode",{parentName:"p"},"database/sql")," specification but returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"sql.DB")," instance. This method provides functionality such as profiling, for which there are no obvious means of exposing through the ",(0,o.kt)("inlineCode",{parentName:"p"},"database/sql")," specification."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func Connect() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    conn := clickhouse.OpenDB(&clickhouse.Options{\n        Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.Port)},\n        Auth: clickhouse.Auth{\n            Database: env.Database,\n            Username: env.Username,\n            Password: env.Password,\n        },\n    })\n    return conn.Ping()\n}\n\n\nfunc ConnectDSN() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    conn, err := sql.Open("clickhouse", fmt.Sprintf("clickhouse://%s:%d?username=%s&password=%s", env.Host, env.Port, env.Username, env.Password))\n    if err != nil {\n        return err\n    }\n    return conn.Ping()\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/connect.go"},"Full Example")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"For all subsequent examples, unless explicitly shown, we assume the use of the ClickHouse ",(0,o.kt)("inlineCode",{parentName:"strong"},"conn")," variable has been created and is available.")),(0,o.kt)("h3",{id:"connection-settings"},"Connection Settings"),(0,o.kt)("p",null,"The following parameters can be passed in the DSN string:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"hosts")," - comma-separated list of single address hosts for load-balancing and failover - see ",(0,o.kt)("a",{parentName:"li",href:"database-sql-api#connecting-to-multiple-nodes"},"Connecting to Multiple Nodes"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"username/password")," - auth credentials - see ",(0,o.kt)("a",{parentName:"li",href:"database-sql-api#authentication"},"Authentication")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"database")," - select the current default database"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"dial_timeout")," - a duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix such as ",(0,o.kt)("inlineCode",{parentName:"li"},"300ms"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"1s"),". Valid time units are ",(0,o.kt)("inlineCode",{parentName:"li"},"ms"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"s"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"m"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"connection_open_strategy")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"random/in_order")," (default ",(0,o.kt)("inlineCode",{parentName:"li"},"random"),") - see ",(0,o.kt)("a",{parentName:"li",href:"database-sql-api#connecting-to-multiple-nodes"},"Connecting to Multiple Nodes"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"round_robin")," - choose a round-robin server from the set"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"in_order")," - first live server is chosen in specified order"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"debug")," - enable debug output (boolean value)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"compress")," - specify the compression algorithm - ",(0,o.kt)("inlineCode",{parentName:"li"},"none")," (default), ",(0,o.kt)("inlineCode",{parentName:"li"},"zstd"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"lz4"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"gzip"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"deflate"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"br"),". If set to ",(0,o.kt)("inlineCode",{parentName:"li"},"true"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"lz4")," will be used. Only ",(0,o.kt)("inlineCode",{parentName:"li"},"lz4")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"zstd")," are supported for native communication."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"compress_level")," - Level of compression (default is ",(0,o.kt)("inlineCode",{parentName:"li"},"0"),"). See Compression. This is algorithm specific:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"gzip")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"-2")," (Best Speed) to ",(0,o.kt)("inlineCode",{parentName:"li"},"9")," (Best Compression)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"deflate")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"-2")," (Best Speed) to ",(0,o.kt)("inlineCode",{parentName:"li"},"9")," (Best Compression)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"br")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"0")," (Best Speed) to ",(0,o.kt)("inlineCode",{parentName:"li"},"11")," (Best Compression)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"zstd"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"lz4")," - ignored"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"secure")," - establish secure SSL connection (default is ",(0,o.kt)("inlineCode",{parentName:"li"},"false"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"skip_verify")," - skip certificate verification (default is ",(0,o.kt)("inlineCode",{parentName:"li"},"false"),")")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func ConnectSettings() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    conn, err := sql.Open("clickhouse", fmt.Sprintf("clickhouse://127.0.0.1:9001,127.0.0.1:9002,%s:%d/%s?username=%s&password=%s&dial_timeout=10s&connection_open_strategy=round_robin&debug=true&compress=lz4", env.Host, env.Port, env.Database, env.Username, env.Password))\n    if err != nil {\n        return err\n    }\n    return conn.Ping()\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/connect_settings.go"},"Full Example")),(0,o.kt)("h3",{id:"connection-pooling"},"Connection Pooling"),(0,o.kt)("p",null,"Users can influence the use of the provided list of node addresses as described in ",(0,o.kt)("a",{parentName:"p",href:"database-sql-api#connecting-to-multiple-nodes"},"Connecting to Multiple Nodes"),". Connection management and pooling is, however, delegated to ",(0,o.kt)("inlineCode",{parentName:"p"},"sql.DB")," by design."),(0,o.kt)("h3",{id:"connecting-over-http"},"Connecting over HTTP"),(0,o.kt)("p",null,"By default, connections are established over the native protocol. For users needing HTTP, this can be enabled by either modifying the DSN to include the HTTP protocol or by specifying the Protocol in the connection options."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func ConnectHTTP() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    conn := clickhouse.OpenDB(&clickhouse.Options{\n        Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.HttpPort)},\n        Auth: clickhouse.Auth{\n            Database: env.Database,\n            Username: env.Username,\n            Password: env.Password,\n        },\n        Protocol: clickhouse.HTTP,\n    })\n    return conn.Ping()\n}\n\nfunc ConnectDSNHTTP() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    conn, err := sql.Open("clickhouse", fmt.Sprintf("http://%s:%d?username=%s&password=%s", env.Host, env.HttpPort, env.Username, env.Password))\n    if err != nil {\n        return err\n    }\n    return conn.Ping()\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/connect_http.go"},"Full Example")),(0,o.kt)("h3",{id:"connecting-to-multiple-nodes"},"Connecting to Multiple Nodes"),(0,o.kt)("p",null,"If using ",(0,o.kt)("inlineCode",{parentName:"p"},"OpenDB"),", connect to multiple hosts using the same options approach as that used for the ClickHouse API - optionally specifying the ConnOpenStrategy."),(0,o.kt)("p",null,"For DSN-based connections, the string accepts multiple hosts and a ",(0,o.kt)("inlineCode",{parentName:"p"},"connection_open_strategy")," parameter for which the value ",(0,o.kt)("inlineCode",{parentName:"p"},"round_robin")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"in_order")," can be set."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func MultiStdHost() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    conn, err := clickhouse.Open(&clickhouse.Options{\n        Addr: []string{"127.0.0.1:9001", "127.0.0.1:9002", fmt.Sprintf("%s:%d", env.Host, env.Port)},\n        Auth: clickhouse.Auth{\n            Database: env.Database,\n            Username: env.Username,\n            Password: env.Password,\n        },\n        ConnOpenStrategy: clickhouse.ConnOpenRoundRobin,\n    })\n    if err != nil {\n        return err\n    }\n    v, err := conn.ServerVersion()\n    if err != nil {\n        return err\n    }\n    fmt.Println(v.String())\n    return nil\n}\n\nfunc MultiStdHostDSN() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    conn, err := sql.Open("clickhouse", fmt.Sprintf("clickhouse://127.0.0.1:9001,127.0.0.1:9002,%s:%d?username=%s&password=%s&connection_open_strategy=round_robin", env.Host, env.Port, env.Username, env.Password))\n    if err != nil {\n        return err\n    }\n    return conn.Ping()\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/multi_host.go"},"Full Example")),(0,o.kt)("h2",{id:"using-tls"},"Using TLS"),(0,o.kt)("p",null,"If using a DSN connection string, SSL can be enabled via the parameter \u201csecure=true\u201d. The OpenDB method utilizes the same approach as the ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#using-tls"},"native API for TLS"),", relying on the specification of a non-nil TLS struct. While the DSN connection string supports the parameter skip_verify to skip SSL verification, the OpenDB method is required for more advanced TLS configurations - since it permits the passing of a configuration. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func ConnectSSL() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    cwd, err := os.Getwd()\n    if err != nil {\n        return err\n    }\n    t := &tls.Config{}\n    caCert, err := ioutil.ReadFile(path.Join(cwd, "../../tests/resources/CAroot.crt"))\n    if err != nil {\n        return err\n    }\n    caCertPool := x509.NewCertPool()\n    successful := caCertPool.AppendCertsFromPEM(caCert)\n    if !successful {\n        return err\n    }\n    t.RootCAs = caCertPool\n\n\n    conn := clickhouse.OpenDB(&clickhouse.Options{\n        Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.SslPort)},\n        Auth: clickhouse.Auth{\n            Database: env.Database,\n            Username: env.Username,\n            Password: env.Password,\n        },\n        TLS: t,\n    })\n    return conn.Ping()\n}\n\nfunc ConnectDSNSSL() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    conn, err := sql.Open("clickhouse", fmt.Sprintf("https://%s:%d?secure=true&skip_verify=true&username=%s&password=%s", env.Host, env.HttpsPort, env.Username, env.Password))\n    if err != nil {\n        return err\n    }\n    return conn.Ping()\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/ssl.go"},"Full Example")),(0,o.kt)("h2",{id:"authentication"},"Authentication"),(0,o.kt)("p",null,"If using OpenDB, authentication information can be passed via the usual options. For DSN-based connections, a username and password can be passed in the connection string - either as parameters or as credentials encoded in the address."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func ConnectAuth() error {\n    env, err := GetStdTestEnvironment()\n    if err != nil {\n        return err\n    }\n    conn := clickhouse.OpenDB(&clickhouse.Options{\n        Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.Port)},\n        Auth: clickhouse.Auth{\n            Database: env.Database,\n            Username: env.Username,\n            Password: env.Password,\n        },\n    })\n    return conn.Ping()\n}\n\nfunc ConnectDSNAuth() error {\n    env, err := GetStdTestEnvironment()\n    conn, err := sql.Open("clickhouse", fmt.Sprintf("http://%s:%d?username=%s&password=%s", env.Host, env.HttpPort, env.Username, env.Password))\n    if err != nil {\n        return err\n    }\n    if err = conn.Ping(); err != nil {\n        return err\n    }\n    conn, err = sql.Open("clickhouse", fmt.Sprintf("http://%s:%s@%s:%d", env.Username, env.Password, env.Host, env.HttpPort))\n    if err != nil {\n        return err\n    }\n    return conn.Ping()\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/auth.go"},"Full Example")),(0,o.kt)("h2",{id:"execution"},"Execution"),(0,o.kt)("p",null,"Once a connection has been obtained, users can issue ",(0,o.kt)("inlineCode",{parentName:"p"},"sql")," statements for execution via the Exec method."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"conn.Exec(`DROP TABLE IF EXISTS example`)\n_, err = conn.Exec(`\n    CREATE TABLE IF NOT EXISTS example (\n        Col1 UInt8,\n        Col2 String\n    ) engine=Memory\n`)\nif err != nil {\n    return err\n}\n_, err = conn.Exec(\"INSERT INTO example VALUES (1, 'test-1')\")\n")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/exec.go"},"Full Example")),(0,o.kt)("p",null,"This method does not support receiving a context - by default, it executes with the background context. Users can use ExecContext if this is needed - see ",(0,o.kt)("a",{parentName:"p",href:"database-sql-api#using-context"},"Using Context"),"."),(0,o.kt)("h2",{id:"batch-insert"},"Batch Insert"),(0,o.kt)("p",null,"Batch semantics can be achieved by creating a ",(0,o.kt)("inlineCode",{parentName:"p"},"sql.Tx")," via the ",(0,o.kt)("inlineCode",{parentName:"p"},"Being")," method. From this, a batch can be obtained using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Prepare")," method with the ",(0,o.kt)("inlineCode",{parentName:"p"},"INSERT")," statement. This returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"sql.Stmt")," to which rows can be appended using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Exec")," method. The batch will be accumulated in memory until ",(0,o.kt)("inlineCode",{parentName:"p"},"Commit")," is executed on the original ",(0,o.kt)("inlineCode",{parentName:"p"},"sql.Tx"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'batch, err := scope.Prepare("INSERT INTO example")\nif err != nil {\n    return err\n}\nfor i := 0; i < 1000; i++ {\n    _, err := batch.Exec(\n        uint8(42),\n        "ClickHouse", "Inc",\n        uuid.New(),\n        map[string]uint8{"key": 1},             // Map(String, UInt8)\n        []string{"Q", "W", "E", "R", "T", "Y"}, // Array(String)\n        []interface{}{ // Tuple(String, UInt8, Array(Map(String, String)))\n            "String Value", uint8(5), []map[string]string{\n                map[string]string{"key": "value"},\n                map[string]string{"key": "value"},\n                map[string]string{"key": "value"},\n            },\n        },\n        time.Now(),\n    )\n    if err != nil {\n        return err\n    }\n}\nreturn scope.Commit()\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/batch.go"},"Full Example")),(0,o.kt)("h2",{id:"querying-rows"},"Querying Row/s"),(0,o.kt)("p",null,"Querying a single row can be achieved using the QueryRow method. This returns a  *sql.Row, on which Scan can be invoked with pointers to variables into which the columns should be marshaled. A QueryRowContext variant allows a context to be passed other than background - see ",(0,o.kt)("a",{parentName:"p",href:"database-sql-api#using-context"},"Using Context"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'row := conn.QueryRow("SELECT * FROM example")\nvar (\n    col1             uint8\n    col2, col3, col4 string\n    col5             map[string]uint8\n    col6             []string\n    col7             interface{}\n    col8             time.Time\n)\nif err := row.Scan(&col1, &col2, &col3, &col4, &col5, &col6, &col7, &col8); err != nil {\n    return err\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/query_row.go"},"Full Example")),(0,o.kt)("p",null,"Iterating multiple rows requires the ",(0,o.kt)("inlineCode",{parentName:"p"},"Query")," method. This returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"*sql.Rows")," struct on which Next can be invoked to iterate through the rows. QueryContext equivalent allows passing of a context."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'rows, err := conn.Query("SELECT * FROM example")\nif err != nil {\n    return err\n}\nvar (\n    col1             uint8\n    col2, col3, col4 string\n    col5             map[string]uint8\n    col6             []string\n    col7             interface{}\n    col8             time.Time\n)\nfor rows.Next() {\n    if err := rows.Scan(&col1, &col2, &col3, &col4, &col5, &col6, &col7, &col8); err != nil {\n        return err\n    }\n    fmt.Printf("row: col1=%d, col2=%s, col3=%s, col4=%s, col5=%v, col6=%v, col7=%v, col8=%v\\n", col1, col2, col3, col4, col5, col6, col7, col8)\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/query_rows.go"},"Full Example")),(0,o.kt)("h2",{id:"async-insert"},"Async Insert"),(0,o.kt)("p",null,"Asynchronous inserts can be achieved by executing an insert via the ExecContext method. This should be passed a context with asynchronous mode enabled, as shown below. This allows the user to specify whether the client should wait for the server to complete the insert or respond once the data has been received. This effectively controls the parameter ",(0,o.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/operations/settings/settings/#wait-for-async-insert"},"wait_for_async_insert"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"const ddl = `\n    CREATE TABLE example (\n            Col1 UInt64\n        , Col2 String\n        , Col3 Array(UInt8)\n        , Col4 DateTime\n    ) ENGINE = Memory\n    `\nif _, err := conn.Exec(ddl); err != nil {\n    return err\n}\nctx := clickhouse.Context(context.Background(), clickhouse.WithStdAsync(false))\n{\n    for i := 0; i < 100; i++ {\n        _, err := conn.ExecContext(ctx, fmt.Sprintf(`INSERT INTO example VALUES (\n            %d, '%s', [1, 2, 3, 4, 5, 6, 7, 8, 9], now()\n        )`, i, \"Golang SQL database driver\"))\n        if err != nil {\n            return err\n        }\n    }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/async.go"},"Full Example")),(0,o.kt)("h2",{id:"columnar-insert"},"Columnar Insert"),(0,o.kt)("p",null,"Not supported using the standard interface."),(0,o.kt)("h2",{id:"using-structs"},"Using Structs"),(0,o.kt)("p",null,"Not supported using the standard interface."),(0,o.kt)("h2",{id:"type-conversions"},"Type Conversions"),(0,o.kt)("p",null,"The standard ",(0,o.kt)("inlineCode",{parentName:"p"},"database/sql")," interface should support the same types as the ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#type-conversions"},"ClickHouse API"),". There are a few exceptions, primarily for complex types, that we document below. Similar to the ClickHouse API, the client aims to be as flexible as possible concerning accepting variable types for both insertion and marshaling of responses. See ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#type-conversions"},"Type Conversions")," for further details."),(0,o.kt)("h2",{id:"complex-types"},"Complex Types"),(0,o.kt)("p",null,"Unless stated, complex type handling should be the same as the ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#complex-types"},"ClickHouse API"),". Differences are a result of ",(0,o.kt)("inlineCode",{parentName:"p"},"database/sql")," internals."),(0,o.kt)("h3",{id:"maps"},"Maps"),(0,o.kt)("p",null,"Unlike the ClickHouse API, the standard API requires maps to be strongly typed at scan type. For example, users cannot pass a ",(0,o.kt)("inlineCode",{parentName:"p"},"map[string]interface{}")," for a ",(0,o.kt)("inlineCode",{parentName:"p"},"Map(String,String)")," field and must use a ",(0,o.kt)("inlineCode",{parentName:"p"},"map[string]string")," instead. An ",(0,o.kt)("inlineCode",{parentName:"p"},"interface{}")," variable will always be compatible and can be used for more complex structures. Structs are not supported at read time."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'var (\n    col1Data = map[string]uint64{\n        "key_col_1_1": 1,\n        "key_col_1_2": 2,\n    }\n    col2Data = map[string]uint64{\n        "key_col_2_1": 10,\n        "key_col_2_2": 20,\n    }\n    col3Data = map[string]uint64{}\n    col4Data = []map[string]string{\n        {"A": "B"},\n        {"C": "D"},\n    }\n    col5Data = map[string]uint64{\n        "key_col_5_1": 100,\n        "key_col_5_2": 200,\n    }\n)\nif _, err := batch.Exec(col1Data, col2Data, col3Data, col4Data, col5Data); err != nil {\n    return err\n}\nif err = scope.Commit(); err != nil {\n    return err\n}\nvar (\n    col1 interface{}\n    col2 map[string]uint64\n    col3 map[string]uint64\n    col4 []map[string]string\n    col5 map[string]uint64\n)\nif err := conn.QueryRow("SELECT * FROM example").Scan(&col1, &col2, &col3, &col4, &col5); err != nil {\n    return err\n}\nfmt.Printf("col1=%v, col2=%v, col3=%v, col4=%v, col5=%v", col1, col2, col3, col4, col5)\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/map.go"},"Full Example")),(0,o.kt)("p",null,"Insert behavior is the same as the ClickHouse API."),(0,o.kt)("h3",{id:"json"},"JSON"),(0,o.kt)("p",null,"The standard API does not support structs or maps at read time. Users must pass an ",(0,o.kt)("inlineCode",{parentName:"p"},"interface{}")," variable to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Scan")," method. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'rows = conn.QueryRow("SELECT event.assignee.Achievement FROM example")\nvar achievement interface{}\nif err = rows.Scan(&achievement); err != nil {\n    return err\n}\nfmt.Println(clickhouse_tests.ToJson(event))\nrows = conn.QueryRow("SELECT event.assignee.Repositories FROM example")\nvar repositories interface{}\nif err = rows.Scan(&repositories); err != nil {\n    return err\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/json.go"},"Full Example")),(0,o.kt)("p",null,"Insert behavior is the same as the ClickHouse API."),(0,o.kt)("h2",{id:"compression"},"Compression"),(0,o.kt)("p",null,"The standard API supports the same compression algorithms as native ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#compression"},"ClickHouse API")," i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"lz4")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"zstd")," compression at a block level. In addition, gzip, deflate and br compression are supported for HTTP connections. If any of these are enabled, compression is performed on blocks during insertion and for query responses. Other requests e.g. pings or query requests, will remain uncompressed. This is consistent with ",(0,o.kt)("inlineCode",{parentName:"p"},"lz4")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"zstd")," options."),(0,o.kt)("p",null,"If using the ",(0,o.kt)("inlineCode",{parentName:"p"},"OpenDB")," method to establish a connection, a Compression configuration can be passed. This includes the ability to specify the compression level (see below). If connecting via ",(0,o.kt)("inlineCode",{parentName:"p"},"sql.Open")," with DSN, utilize the parameter ",(0,o.kt)("inlineCode",{parentName:"p"},"compress"),". This can either be a specific compression algorithm i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"gzip"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"deflate"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"br"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"zstd")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"lz4")," or a boolean flag. If set to true, ",(0,o.kt)("inlineCode",{parentName:"p"},"lz4")," will be used. The default is ",(0,o.kt)("inlineCode",{parentName:"p"},"none")," i.e. compression disabled."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'conn := clickhouse.OpenDB(&clickhouse.Options{\n    Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.HttpPort)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n    Compression: &clickhouse.Compression{\n        Method: clickhouse.CompressionBrotli,\n        Level:  5,\n    },\n    Protocol: clickhouse.HTTP,\n})\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/compression.go#L27-L76"},"Full Example")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := sql.Open("clickhouse", fmt.Sprintf("http://%s:%d?username=%s&password=%s&compress=gzip&compress_level=5", env.Host, env.HttpPort, env.Username, env.Password))\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/compression.go#L78-L115"},"Full Example")),(0,o.kt)("p",null,"The level of applied compression can be controlled by the DSN parameter compress_level or the Level field of the Compression option. This defaults to 0 but is algorithm specific:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"gzip")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"-2")," (Best Speed) to ",(0,o.kt)("inlineCode",{parentName:"li"},"9")," (Best Compression)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"deflate")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"-2")," (Best Speed) to ",(0,o.kt)("inlineCode",{parentName:"li"},"9")," (Best Compression)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"br")," - ",(0,o.kt)("inlineCode",{parentName:"li"},"0")," (Best Speed) to ",(0,o.kt)("inlineCode",{parentName:"li"},"11")," (Best Compression)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"zstd"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"lz4")," - ignored")),(0,o.kt)("h2",{id:"parameter-binding"},"Parameter Binding"),(0,o.kt)("p",null,"The standard API supports the same parameter binding capabilities as the ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#parameter-binding"},"ClickHouse API"),", allowing parameters to be passed to the Exec, Query and QueryRow methods (and their equivalent ",(0,o.kt)("a",{parentName:"p",href:"database-sql-api#using-context"},"Context")," variants). Positional, named and numbered parameters are supported."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'var count uint64\n// positional bind\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col1 >= ? AND Col3 < ?", 500, now.Add(time.Duration(750)*time.Second)).Scan(&count); err != nil {\n    return err\n}\n// 250\nfmt.Printf("Positional bind count: %d\\n", count)\n// numeric bind\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col1 <= $2 AND Col3 > $1", now.Add(time.Duration(150)*time.Second), 250).Scan(&count); err != nil {\n    return err\n}\n// 100\nfmt.Printf("Numeric bind count: %d\\n", count)\n// named bind\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col1 <= @col1 AND Col3 > @col3", clickhouse.Named("col1", 100), clickhouse.Named("col3", now.Add(time.Duration(50)*time.Second))).Scan(&count); err != nil {\n    return err\n}\n// 50\nfmt.Printf("Named bind count: %d\\n", count)\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/bind.go"},"Full Example")),(0,o.kt)("p",null,"Note ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#special-cases"},"special cases")," still apply."),(0,o.kt)("h2",{id:"using-context"},"Using Context"),(0,o.kt)("p",null,"The standard API supports the same ability to pass deadlines, cancellation signals, and other request-scoped values via the context as the ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#using-context"},"ClickHouse API"),". Unlike the ClickHouse API, this is achieved by using ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," variants of the methods i.e. methods such as ",(0,o.kt)("inlineCode",{parentName:"p"},"Exec"),", which use the background context by default, have a variant ",(0,o.kt)("inlineCode",{parentName:"p"},"ExecContext")," to which a context can be passed as the first parameter. This allows a context to be passed at any stage of an application flow. For example, users can pass a context when establishing a connection via ",(0,o.kt)("inlineCode",{parentName:"p"},"ConnContext")," or when requesting a query row via ",(0,o.kt)("inlineCode",{parentName:"p"},"QueryRowContext"),". Examples of all available methods are shown below."),(0,o.kt)("p",null,"For more detail on using the context to pass deadlines, cancellation signals, query ids, quota keys and connection settings see Using Context for the ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#using-context"},"ClickHouse API"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'ctx := clickhouse.Context(context.Background(), clickhouse.WithSettings(clickhouse.Settings{\n    "allow_experimental_object_type": "1",\n}))\nconn.ExecContext(ctx, "DROP TABLE IF EXISTS example")\n// to create a JSON column we need allow_experimental_object_type=1\nif _, err = conn.ExecContext(ctx, `\n    CREATE TABLE example (\n            Col1 JSON\n        ) \n        Engine Memory\n    `); err != nil {\n    return err\n}\n\n// queries can be cancelled using the context\nctx, cancel := context.WithCancel(context.Background())\ngo func() {\n    cancel()\n}()\nif err = conn.QueryRowContext(ctx, "SELECT sleep(3)").Scan(); err == nil {\n    return fmt.Errorf("expected cancel")\n}\n\n// set a deadline for a query - this will cancel the query after the absolute time is reached. Again terminates the connection only,\n// queries will continue to completion in ClickHouse\nctx, cancel = context.WithDeadline(context.Background(), time.Now().Add(-time.Second))\ndefer cancel()\nif err := conn.PingContext(ctx); err == nil {\n    return fmt.Errorf("expected deadline exceeeded")\n}\n\n// set a query id to assist tracing queries in logs e.g. see system.query_log\nvar one uint8\nctx = clickhouse.Context(context.Background(), clickhouse.WithQueryID(uuid.NewString()))\nif err = conn.QueryRowContext(ctx, "SELECT 1").Scan(&one); err != nil {\n    return err\n}\n\nconn.ExecContext(context.Background(), "DROP QUOTA IF EXISTS foobar")\ndefer func() {\n    conn.ExecContext(context.Background(), "DROP QUOTA IF EXISTS foobar")\n}()\nctx = clickhouse.Context(context.Background(), clickhouse.WithQuotaKey("abcde"))\n// set a quota key - first create the quota\nif _, err = conn.ExecContext(ctx, "CREATE QUOTA IF NOT EXISTS foobar KEYED BY client_key FOR INTERVAL 1 minute MAX queries = 5 TO default"); err != nil {\n    return err\n}\n\n// queries can be cancelled using the context\nctx, cancel = context.WithCancel(context.Background())\n// we will get some results before cancel\nctx = clickhouse.Context(ctx, clickhouse.WithSettings(clickhouse.Settings{\n    "max_block_size": "1",\n}))\nrows, err := conn.QueryContext(ctx, "SELECT sleepEachRow(1), number FROM numbers(100);")\nif err != nil {\n    return err\n}\nvar (\n    col1 uint8\n    col2 uint8\n)\n\nfor rows.Next() {\n    if err := rows.Scan(&col1, &col2); err != nil {\n        if col2 > 3 {\n            fmt.Println("expected cancel")\n            return nil\n        }\n        return err\n    }\n    fmt.Printf("row: col2=%d\\n", col2)\n    if col2 == 3 {\n        cancel()\n    }\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/context.go"},"Full Example")),(0,o.kt)("h2",{id:"sessions"},"Sessions"),(0,o.kt)("p",null,"While native connections inherently have a session, connections over HTTP require the user to create a session id for passing in a context as a setting. This allows the use of features, e.g., Temporary tables, which are bound to a session. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'conn := clickhouse.OpenDB(&clickhouse.Options{\n    Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.HttpPort)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n    Protocol: clickhouse.HTTP,\n    Settings: clickhouse.Settings{\n        "session_id": uuid.NewString(),\n    },\n})\nif _, err := conn.Exec(`DROP TABLE IF EXISTS example`); err != nil {\n    return err\n}\n_, err = conn.Exec(`\n    CREATE TEMPORARY TABLE IF NOT EXISTS example (\n            Col1 UInt8\n    )\n`)\nif err != nil {\n    return err\n}\nscope, err := conn.Begin()\nif err != nil {\n    return err\n}\nbatch, err := scope.Prepare("INSERT INTO example")\nif err != nil {\n    return err\n}\nfor i := 0; i < 10; i++ {\n    _, err := batch.Exec(\n        uint8(i),\n    )\n    if err != nil {\n        return err\n    }\n}\nrows, err := conn.Query("SELECT * FROM example")\nif err != nil {\n    return err\n}\nvar (\n    col1 uint8\n)\nfor rows.Next() {\n    if err := rows.Scan(&col1); err != nil {\n        return err\n    }\n    fmt.Printf("row: col1=%d\\n", col1)\n}\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/session.go"},"Full Example")),(0,o.kt)("h2",{id:"dynamic-scanning"},"Dynamic Scanning"),(0,o.kt)("p",null,"Similar to the ",(0,o.kt)("a",{parentName:"p",href:"clickhouse-api#dynamic-scanning"},"ClickHouse API"),", column type information is available to allow users to create runtime instances of correctly typed variables which can be passed to Scan. This allows columns to be read where the type is not known."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"const query = `\nSELECT\n        1     AS Col1\n    , 'Text' AS Col2\n`\nrows, err := conn.QueryContext(context.Background(), query)\nif err != nil {\n    return err\n}\ncolumnTypes, err := rows.ColumnTypes()\nif err != nil {\n    return err\n}\nvars := make([]interface{}, len(columnTypes))\nfor i := range columnTypes {\n    vars[i] = reflect.New(columnTypes[i].ScanType()).Interface()\n}\nfor rows.Next() {\n    if err := rows.Scan(vars...); err != nil {\n        return err\n    }\n    for _, v := range vars {\n        switch v := v.(type) {\n        case *string:\n            fmt.Println(*v)\n        case *uint8:\n            fmt.Println(*v)\n        }\n    }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/dynamic_scan_types.go"},"Full Example")),(0,o.kt)("h2",{id:"external-tables"},"External Tables"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/engines/table-engines/special/external-data/"},"External tables")," allow the client to send data to ClickHouse, with a ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," query. This data is put in a temporary table and can be used in the query itself for evaluation."),(0,o.kt)("p",null,"To send external data to the client with a query, the user must build an external table via ",(0,o.kt)("inlineCode",{parentName:"p"},"ext.NewTable")," before passing this via the context. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'table1, err := ext.NewTable("external_table_1",\n    ext.Column("col1", "UInt8"),\n    ext.Column("col2", "String"),\n    ext.Column("col3", "DateTime"),\n)\nif err != nil {\n    return err\n}\n\nfor i := 0; i < 10; i++ {\n    if err = table1.Append(uint8(i), fmt.Sprintf("value_%d", i), time.Now()); err != nil {\n        return err\n    }\n}\n\ntable2, err := ext.NewTable("external_table_2",\n    ext.Column("col1", "UInt8"),\n    ext.Column("col2", "String"),\n    ext.Column("col3", "DateTime"),\n)\n\nfor i := 0; i < 10; i++ {\n    table2.Append(uint8(i), fmt.Sprintf("value_%d", i), time.Now())\n}\nctx := clickhouse.Context(context.Background(),\n    clickhouse.WithExternalTable(table1, table2),\n)\nrows, err := conn.QueryContext(ctx, "SELECT * FROM external_table_1")\nif err != nil {\n    return err\n}\nfor rows.Next() {\n    var (\n        col1 uint8\n        col2 string\n        col3 time.Time\n    )\n    rows.Scan(&col1, &col2, &col3)\n    fmt.Printf("col1=%d, col2=%s, col3=%v\\n", col1, col2, col3)\n}\nrows.Close()\n\n\nvar count uint64\nif err := conn.QueryRowContext(ctx, "SELECT COUNT(*) FROM external_table_1").Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("external_table_1: %d\\n", count)\nif err := conn.QueryRowContext(ctx, "SELECT COUNT(*) FROM external_table_2").Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("external_table_2: %d\\n", count)\nif err := conn.QueryRowContext(ctx, "SELECT COUNT(*) FROM (SELECT * FROM external_table_1 UNION ALL SELECT * FROM external_table_2)").Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("external_table_1 UNION external_table_2: %d\\n", count)\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/external_data.go"},"Full Example")),(0,o.kt)("h2",{id:"open-telemetry"},"Open Telemetry"),(0,o.kt)("p",null,"ClickHouse allows a ",(0,o.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/operations/opentelemetry/"},"trace context")," to be passed as part of the native protocol. The client allows a Span to be created via the function ",(0,o.kt)("inlineCode",{parentName:"p"},"clickhouse.withSpan")," and passed via the Context to achieve this. This is not supported when HTTP is used as transport."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'var count uint64\nrows := conn.QueryRowContext(clickhouse.Context(context.Background(), clickhouse.WithSpan(\n    trace.NewSpanContext(trace.SpanContextConfig{\n        SpanID:  trace.SpanID{1, 2, 3, 4, 5},\n        TraceID: trace.TraceID{5, 4, 3, 2, 1},\n    }),\n)), "SELECT COUNT() FROM (SELECT number FROM system.numbers LIMIT 5)")\nif err := rows.Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("count: %d\\n", count)\n')),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/std/open_telemetry.go"},"Full Example")))}d.isMDXComponent=!0}}]);