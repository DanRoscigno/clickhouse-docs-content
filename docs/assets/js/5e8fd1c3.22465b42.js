"use strict";(self.webpackChunkclickhouse=self.webpackChunkclickhouse||[]).push([[96313],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return d}});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=c(t),d=o,h=m["".concat(s,".").concat(d)]||m[d]||p[d]||i;return t?r.createElement(h,a(a({ref:n},u),{},{components:t})):r.createElement(h,a({ref:n},u))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var c=2;c<i;c++)a[c]=t[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},60251:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var r=t(87462),o=t(63366),i=(t(67294),t(3905)),a=["components"],l={sidebar_label:"ClickHouse Client API",sidebar_position:3,keywords:["clickhouse","go","client","high-level","api"],slug:"/en/integrations/go/clickhouse-go/clickhouse-api",description:"ClickHouse Client API"},s="ClickHouse Client API",c={unversionedId:"en/integrations/language-clients/go/clickhouse-go/clickhouse-api",id:"en/integrations/language-clients/go/clickhouse-go/clickhouse-api",title:"ClickHouse Client API",description:"ClickHouse Client API",source:"@site/docs/en/integrations/language-clients/go/clickhouse-go/clickhouse-api.md",sourceDirName:"en/integrations/language-clients/go/clickhouse-go",slug:"/en/integrations/go/clickhouse-go/clickhouse-api",permalink:"/docs/en/integrations/go/clickhouse-go/clickhouse-api",draft:!1,editUrl:"https://github.com/ClickHouse/clickhouse-docs/blob/main/docs/en/integrations/language-clients/go/clickhouse-go/clickhouse-api.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_label:"ClickHouse Client API",sidebar_position:3,keywords:["clickhouse","go","client","high-level","api"],slug:"/en/integrations/go/clickhouse-go/clickhouse-api",description:"ClickHouse Client API"},sidebar:"english",previous:{title:"Installation",permalink:"/docs/en/integrations/go/clickhouse-go/installation"},next:{title:"Database/SQL API",permalink:"/docs/en/integrations/go/clickhouse-go/database-sql-api"}},u={},p=[{value:"Connecting",id:"connecting",level:2},{value:"Connection Settings",id:"connection-settings",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Using TLS",id:"using-tls",level:2},{value:"Authentication",id:"authentication",level:2},{value:"Connecting to Multiple Nodes",id:"connecting-to-multiple-nodes",level:2},{value:"Execution",id:"execution",level:2},{value:"Batch Insert",id:"batch-insert",level:2},{value:"Querying Row/s",id:"querying-rows",level:2},{value:"Async Insert",id:"async-insert",level:2},{value:"Columnar Insert",id:"columnar-insert",level:2},{value:"Using Structs",id:"using-structs",level:2},{value:"Select with Serialize",id:"select-with-serialize",level:3},{value:"Scan Struct",id:"scan-struct",level:3},{value:"Append Struct",id:"append-struct",level:3},{value:"Type Conversions",id:"type-conversions",level:2},{value:"Complex Types",id:"complex-types",level:2},{value:"Date/DateTime types",id:"datedatetime-types",level:3},{value:"Array",id:"array",level:3},{value:"Map",id:"map",level:3},{value:"Tuples",id:"tuples",level:3},{value:"Nested",id:"nested",level:3},{value:"JSON",id:"json",level:3},{value:"Important Notes",id:"important-notes",level:4},{value:"Geo Types",id:"geo-types",level:3},{value:"UUID",id:"uuid",level:3},{value:"Decimal",id:"decimal",level:3},{value:"Nullable",id:"nullable",level:3},{value:"Big Ints -  Int128, Int256, UInt128, UInt256",id:"big-ints----int128-int256-uint128-uint256",level:3},{value:"Compression",id:"compression",level:2},{value:"Parameter Binding",id:"parameter-binding",level:3},{value:"Special Cases",id:"special-cases",level:3},{value:"Using Context",id:"using-context",level:2},{value:"Progress/Profile/Log Information",id:"progressprofilelog-information",level:2},{value:"Dynamic Scanning",id:"dynamic-scanning",level:2},{value:"External tables",id:"external-tables",level:2},{value:"Open Telemetry",id:"open-telemetry",level:2}],m={toc:p};function d(e){var n=e.components,t=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"clickhouse-client-api"},"ClickHouse Client API"),(0,i.kt)("p",null,"All code examples for the ClickHouse Client API can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/tree/main/examples"},"here"),"."),(0,i.kt)("h2",{id:"connecting"},"Connecting"),(0,i.kt)("p",null,"The following example, which returns the server version, demonstrates connecting to ClickHouse - assuming ClickHouse is not secured and accessible with the default user."),(0,i.kt)("p",null,"Note we use the default native port to connect."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := clickhouse.Open(&clickhouse.Options{\n    Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.Port)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n})\nif err != nil {\n    return err\n}\nv, err := conn.ServerVersion()\nfmt.Println(v)\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/connect.go"},"Full Example")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"For all subsequent examples, unless explicitly shown, we assume the use of the ClickHouse ",(0,i.kt)("inlineCode",{parentName:"strong"},"conn")," variable has been created and is available.")),(0,i.kt)("h3",{id:"connection-settings"},"Connection Settings"),(0,i.kt)("p",null,"When opening a connection, an Options struct can be used to control client behavior. The following settings are available:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Protocol")," - either Native or HTTP. HTTP is only supported currently for the ",(0,i.kt)("a",{parentName:"li",href:"./database-sql-api"},"database/sql API"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TLS")," - TLS options. A non-nil value enables TLS. See ",(0,i.kt)("a",{parentName:"li",href:"clickhouse-api#using-tls"},"Using TLS"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Addr")," - a slice of addresses including port."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Auth")," - Authentication detail. See ",(0,i.kt)("a",{parentName:"li",href:"clickhouse-api#authentication"},"Authentication"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DialContext")," - custom dial function to determine how connections are established. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Debug")," - true/false to enable debugging."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Debugf")," - provides a function to consume debug output. Requires ",(0,i.kt)("inlineCode",{parentName:"li"},"debug")," to be set to true."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Settings")," - map of ClickHouse settings. These will be applied to all ClickHouse queries. ",(0,i.kt)("a",{parentName:"li",href:"clickhouse-api#using-context"},"Using Context")," allows settings to be set per query."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Compression")," - enable compression for blocks. See ",(0,i.kt)("a",{parentName:"li",href:"clickhouse-api#compression"},"Compression"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"DialTimeout")," - the maximum time to establish a connection. Defaults to 1s."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MaxOpenConns")," - max connections for use at any time. More or fewer connections may be in the idle pool, but only this number can be used at any time. Defaults to MaxIdleConns+5. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MaxIdleConns")," - number of connections to maintain in the pool. Connections will be reused if possible. Defaults to 5."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ConnMaxLifetime")," - maximum lifetime to keep a connection available. Defaults to 1hr. Connections are destroyed after this time, with new connections added to the pool as required."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ConnOpenStrategy")," - determines how the list of node addresses should be consumed and used to open connections. See ",(0,i.kt)("a",{parentName:"li",href:"clickhouse-api#connecting-to-multiple-nodes"},"Connecting to Multiple Nodes"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := clickhouse.Open(&clickhouse.Options{\n    Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.Port)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n    DialContext: func(ctx context.Context, addr string) (net.Conn, error) {\n        dialCount++\n        var d net.Dialer\n        return d.DialContext(ctx, "tcp", addr)\n    },\n    Debug: true,\n    Debugf: func(format string, v ...interface{}) {\n        fmt.Printf(format, v)\n    },\n    Settings: clickhouse.Settings{\n        "max_execution_time": 60,\n    },\n    Compression: &clickhouse.Compression{\n        Method: clickhouse.CompressionLZ4,\n    },\n    DialTimeout:      time.Duration(10) * time.Second,\n    MaxOpenConns:     5,\n    MaxIdleConns:     5,\n    ConnMaxLifetime:  time.Duration(10) * time.Minute,\n    ConnOpenStrategy: clickhouse.ConnOpenInOrder,\n})\nif err != nil {\n    return err\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/connect_settings.go"},"Full Example")),(0,i.kt)("h3",{id:"connection-pooling"},"Connection Pooling"),(0,i.kt)("p",null,"The client maintains a pool of connections, reusing these across queries as required. At most, ",(0,i.kt)("inlineCode",{parentName:"p"},"MaxOpenConns")," will be used at any time, with the maximum pool size controlled by the ",(0,i.kt)("inlineCode",{parentName:"p"},"MaxIdleConns"),". The client will acquire a connection from the pool for each query execution, returning it to the pool for reuse. A connection is used for the lifetime of a batch and released on ",(0,i.kt)("inlineCode",{parentName:"p"},"Send()"),"."),(0,i.kt)("p",null,"There is no guarantee the same connection in a pool will be used for subsequent queries unless the user sets ",(0,i.kt)("inlineCode",{parentName:"p"},"MaxOpenConns=1"),". This is rarely needed but may be required for cases where users are using temporary tables."),(0,i.kt)("p",null,"Also, note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnMaxLifetime")," is by default 1hr. This can lead to cases where the load to ClickHouse becomes unbalanced if nodes leave the cluster. This can occur when a node becomes unavailable, connections will balance to the other nodes. These connections will persist and not be refreshed for 1hr by default, even if the problematic node returns to the cluster. Consider lowering this value in heavy workload cases."),(0,i.kt)("h2",{id:"using-tls"},"Using TLS"),(0,i.kt)("p",null,"At a low level, all client connect methods (DSN/OpenDB/Open) will use the",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/crypto/tls"}," Go tls package")," to establish a secure connection. The client knows to use TLS if the Options struct contains a non-nil ",(0,i.kt)("inlineCode",{parentName:"p"},"tls.Config")," pointer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'env, err := GetNativeTestEnvironment()\nif err != nil {\n    return err\n}\ncwd, err := os.Getwd()\nif err != nil {\n    return err\n}\nt := &tls.Config{}\ncaCert, err := ioutil.ReadFile(path.Join(cwd, "../../tests/resources/CAroot.crt"))\nif err != nil {\n    return err\n}\ncaCertPool := x509.NewCertPool()\nsuccessful := caCertPool.AppendCertsFromPEM(caCert)\nif !successful {\n    return err\n}\nt.RootCAs = caCertPool\nconn, err := clickhouse.Open(&clickhouse.Options{\n    Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.SslPort)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n    TLS: t,\n})\nif err != nil {\n    return err\n}\nv, err := conn.ServerVersion()\nif err != nil {\n    return err\n}\nfmt.Println(v.String())\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/ssl.go"},"Full Example")),(0,i.kt)("p",null,"This is minimal ",(0,i.kt)("inlineCode",{parentName:"p"},"TLS.Config")," is normally sufficient to connect to the secure native port (normally 9440) on a ClickHouse server. If the ClickHouse server does not have a valid certificate (expired, wrong hostname, not signed by a publicly recognized root Certificate Authority), InsecureSkipVerify can be true, but this is strongly discouraged."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := clickhouse.Open(&clickhouse.Options{\n    Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.SslPort)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n    TLS: &tls.Config{\n        InsecureSkipVerify: true,\n    },\n})\nif err != nil {\n    return err\n}\nv, err := conn.ServerVersion()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/ssl_no_verify.go"},"Full Example")),(0,i.kt)("p",null,"If additional TLS parameters are necessary, the application code should set the desired fields in the ",(0,i.kt)("inlineCode",{parentName:"p"},"tls.Config")," struct. That can include specific cipher suites, forcing a particular TLS version (like 1.2 or 1.3), adding an internal CA certificate chain, adding a client certificate (and private key) if required by the ClickHouse server, and most of the other options that come with a more specialized security setup."),(0,i.kt)("h2",{id:"authentication"},"Authentication"),(0,i.kt)("p",null,"Specify an Auth struct in the connection details to specify a username and password."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := clickhouse.Open(&clickhouse.Options{\n    Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.Port)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n})\nif err != nil {\n    return err\n}\nif err != nil {\n    return err\n}\nv, err := conn.ServerVersion()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/auth.go"},"Full Example")),(0,i.kt)("h2",{id:"connecting-to-multiple-nodes"},"Connecting to Multiple Nodes"),(0,i.kt)("p",null,"Multiple addresses can be specified via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Addr")," struct."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := clickhouse.Open(&clickhouse.Options{\n    Addr: []string{"127.0.0.1:9001", "127.0.0.1:9002", fmt.Sprintf("%s:%d", env.Host, env.Port)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n})\nif err != nil {\n    return err\n}\nv, err := conn.ServerVersion()\nif err != nil {\n    return err\n}\nfmt.Println(v.String())\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/1c0d81d0b1388dbb9e09209e535667df212f4ae4/examples/clickhouse_api/multi_host.go#L26-L45"},"Full Example")),(0,i.kt)("p",null,"Two connection strategies are available: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ConnOpenInOrder")," (default)  - addresses are consumed in order. Later addresses are only utilized in case of failure to connect using addresses earlier in the list. This is effectively a failure-over strategy."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ConnOpenRoundRobin")," - Load is balanced across the addresses using a round-robin strategy.")),(0,i.kt)("p",null,"This can be controlled through the option ",(0,i.kt)("inlineCode",{parentName:"p"},"ConnOpenStrategy")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := clickhouse.Open(&clickhouse.Options{\n    Addr:             []string{"127.0.0.1:9001", "127.0.0.1:9002", fmt.Sprintf("%s:%d", env.Host, env.Port)},\n    ConnOpenStrategy: clickhouse.ConnOpenRoundRobin,\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n})\nif err != nil {\n    return err\n}\nv, err := conn.ServerVersion()\nif err != nil {\n    return err\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/1c0d81d0b1388dbb9e09209e535667df212f4ae4/examples/clickhouse_api/multi_host.go#L50-L67"},"Full Example")," "),(0,i.kt)("h2",{id:"execution"},"Execution"),(0,i.kt)("p",null,"Arbitrary statements can be executed via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Exec")," method. This is useful for DDL and simple statements. It should not be used for larger inserts or query iterations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"conn.Exec(context.Background(), `DROP TABLE IF EXISTS example`)\nerr = conn.Exec(context.Background(), `\n    CREATE TABLE IF NOT EXISTS example (\n        Col1 UInt8,\n        Col2 String\n    ) engine=Memory\n`)\nif err != nil {\n    return err\n}\nconn.Exec(context.Background(), \"INSERT INTO example VALUES (1, 'test-1')\")\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/exec.go"},"Full Example")),(0,i.kt)("p",null,"Note the ability to pass a Context to the query. This can be used to pass specific query level settings - see ",(0,i.kt)("a",{parentName:"p",href:"clickhouse-api#using-context"},"Using Context"),"."),(0,i.kt)("h2",{id:"batch-insert"},"Batch Insert"),(0,i.kt)("p",null,"To insert a large number of rows, the client provides batch semantics. This requires the preparation of a batch to which rows can be appended. This is finally sent via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Send()")," method. Batches will be held in memory until Send is executed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := GetNativeConnection(nil, nil, nil)\nif err != nil {\n    return err\n}\nctx := context.Background()\ndefer func() {\n    conn.Exec(ctx, "DROP TABLE example")\n}()\nconn.Exec(context.Background(), "DROP TABLE IF EXISTS example")\nerr = conn.Exec(ctx, `\n    CREATE TABLE IF NOT EXISTS example (\n            Col1 UInt8\n        , Col2 String\n        , Col3 FixedString(3)\n        , Col4 UUID\n        , Col5 Map(String, UInt8)\n        , Col6 Array(String)\n        , Col7 Tuple(String, UInt8, Array(Map(String, String)))\n        , Col8 DateTime\n    ) Engine = Memory\n`)\nif err != nil {\n    return err\n}\n\n\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\nfor i := 0; i < 1000; i++ {\n    err := batch.Append(\n        uint8(42),\n        "ClickHouse",\n        "Inc",\n        uuid.New(),\n        map[string]uint8{"key": 1},             // Map(String, UInt8)\n        []string{"Q", "W", "E", "R", "T", "Y"}, // Array(String)\n        []interface{}{ // Tuple(String, UInt8, Array(Map(String, String)))\n            "String Value", uint8(5), []map[string]string{\n                {"key": "value"},\n                {"key": "value"},\n                {"key": "value"},\n            },\n        },\n        time.Now(),\n    )\n    if err != nil {\n        return err\n    }\n}\nreturn batch.Send()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/batch.go"},"Full Example")),(0,i.kt)("p",null,"Recommendations for ClickHouse apply ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/about-us/performance/#performance-when-inserting-data"},"here"),". Batches should not be shared across go-routines - construct a separate batch per routine.  "),(0,i.kt)("p",null,"From the above example, note the need for variable types to align with the column type when appending rows. While the mapping is usually obvious, this interface tries to be flexible, and types will be converted provided no precision loss is incurred. For example, the following demonstrates inserting a string into a datetime64."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'batch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\nfor i := 0; i < 1000; i++ {\n    err := batch.Append(\n        "2006-01-02 15:04:05.999",\n    )\n    if err != nil {\n        return err\n    }\n}\nreturn batch.Send()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/type_convert.go"},"Full Example")),(0,i.kt)("p",null,"For a full summary of supported go types for each column type, see ",(0,i.kt)("a",{parentName:"p",href:"clickhouse-api#type-conversions"},"Type Conversions"),"."),(0,i.kt)("h2",{id:"querying-rows"},"Querying Row/s"),(0,i.kt)("p",null,"Users can either query for a single row using the ",(0,i.kt)("inlineCode",{parentName:"p"},"QueryRow")," method or obtain a cursor for iteration over a result set via ",(0,i.kt)("inlineCode",{parentName:"p"},"QueryRow"),". While the former accepts a destination for the data to be serialized into, the latter requires the to call ",(0,i.kt)("inlineCode",{parentName:"p"},"Scan")," on each row."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'row := conn.QueryRow(context.Background(), "SELECT * FROM example")\nvar (\n    col1             uint8\n    col2, col3, col4 string\n    col5             map[string]uint8\n    col6             []string\n    col7             []interface{}\n    col8             time.Time\n)\nif err := row.Scan(&col1, &col2, &col3, &col4, &col5, &col6, &col7, &col8); err != nil {\n    return err\n}\nfmt.Printf("row: col1=%d, col2=%s, col3=%s, col4=%s, col5=%v, col6=%v, col7=%v, col8=%v\\n", col1, col2, col3, col4, col5, col6, col7, col8)\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/query_row.go"},"Full Example")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'rows, err := conn.Query(ctx, "SELECT Col1, Col2, Col3 FROM example WHERE Col1 >= 2")\nif err != nil {\n    return err\n}\nfor rows.Next() {\n    var (\n        col1 uint8\n        col2 string\n        col3 time.Time\n    )\n    if err := rows.Scan(&col1, &col2, &col3); err != nil {\n        return err\n    }\n    fmt.Printf("row: col1=%d, col2=%s, col3=%s\\n", col1, col2, col3)\n}\nrows.Close()\nreturn rows.Err()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/query_rows.go"},"Full Example")),(0,i.kt)("p",null,"Note in both cases, we are required to pass a pointer to the variables we wish to serialize the respective column values into. These must be passed in the order specified in the ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT")," statement - by default, the order of column declaration will be used in the event of a ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT *")," as shown above."),(0,i.kt)("p",null,"Similar to insertion, the Scan method requires the target variables to be of an appropriate type. This again aims to be flexible, with types converted where possible, provided no precision loss is possible, e.g., the above example shows a UUID column being read into a string variable. For a full list of supported go types for each Column type, see ",(0,i.kt)("a",{parentName:"p",href:"clickhouse-api#type-conversions"},"Type Conversions"),"."),(0,i.kt)("p",null,"Finally, note the ability to pass a Context to the Query and QueryRow methods. This can be used for query level settings - see ",(0,i.kt)("a",{parentName:"p",href:"clickhouse-api#using-context"},"Using Context")," for further details."),(0,i.kt)("h2",{id:"async-insert"},"Async Insert"),(0,i.kt)("p",null,"Asynchronous inserts are supported through the Async method. This allows the user to specify whether the client should wait for the server to complete the insert or respond once the data has been received. This effectively controls the parameter ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/operations/settings/settings/#wait-for-async-insert"},"wait_for_async_insert"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := GetNativeConnection(nil, nil, nil)\nif err != nil {\n    return err\n}\nctx := context.Background()\nif err := clickhouse_tests.CheckMinServerServerVersion(conn, 21, 12, 0); err != nil {\n    return nil\n}\ndefer func() {\n    conn.Exec(ctx, "DROP TABLE example")\n}()\nconn.Exec(ctx, `DROP TABLE IF EXISTS example`)\nconst ddl = `\n    CREATE TABLE example (\n            Col1 UInt64\n        , Col2 String\n        , Col3 Array(UInt8)\n        , Col4 DateTime\n    ) ENGINE = Memory\n`\nif err := conn.Exec(ctx, ddl); err != nil {\n    return err\n}\nfor i := 0; i < 100; i++ {\n    if err := conn.AsyncInsert(ctx, fmt.Sprintf(`INSERT INTO example VALUES (\n        %d, \'%s\', [1, 2, 3, 4, 5, 6, 7, 8, 9], now()\n    )`, i, "Golang SQL database driver"), false); err != nil {\n        return err\n    }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/async.go"},"Full Example")),(0,i.kt)("h2",{id:"columnar-insert"},"Columnar Insert"),(0,i.kt)("p",null,"Inserts can be inserted in column format. This can provide performance benefits if the data is already orientated in this structure by avoiding the need to pivot to rows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'batch, err := conn.PrepareBatch(context.Background(), "INSERT INTO example")\nif err != nil {\n    return err\n}\nvar (\n    col1 []uint64\n    col2 []string\n    col3 [][]uint8\n    col4 []time.Time\n)\nfor i := 0; i < 1_000; i++ {\n    col1 = append(col1, uint64(i))\n    col2 = append(col2, "Golang SQL database driver")\n    col3 = append(col3, []uint8{1, 2, 3, 4, 5, 6, 7, 8, 9})\n    col4 = append(col4, time.Now())\n}\nif err := batch.Column(0).Append(col1); err != nil {\n    return err\n}\nif err := batch.Column(1).Append(col2); err != nil {\n    return err\n}\nif err := batch.Column(2).Append(col3); err != nil {\n    return err\n}\nif err := batch.Column(3).Append(col4); err != nil {\n    return err\n}\nreturn batch.Send()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/columnar_insert.go"},"Full Example")),(0,i.kt)("h2",{id:"using-structs"},"Using Structs"),(0,i.kt)("p",null,"For users, Golang structs provide a logical representation of a row of data in ClickHouse. To assist with this, the native interface provides several convenient functions."),(0,i.kt)("h3",{id:"select-with-serialize"},"Select with Serialize"),(0,i.kt)("p",null,"The Select method allows a set of response rows to be marshaled into a slice of structs with a single invocation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var result []struct {\n    Col1           uint8\n    Col2           string\n    ColumnWithName time.Time `ch:"Col3"`\n}\n\nif err = conn.Select(ctx, &result, "SELECT Col1, Col2, Col3 FROM example"); err != nil {\n    return err\n}\n\nfor _, v := range result {\n    fmt.Printf("row: col1=%d, col2=%s, col3=%s\\n", v.Col1, v.Col2, v.ColumnWithName)\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/select_struct.go"},"Full Example")),(0,i.kt)("h3",{id:"scan-struct"},"Scan Struct"),(0,i.kt)("p",null,"ScanStruct allows the marshaling of a single Row from a query into a struct."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var result struct {\n    Col1  int64\n    Count uint64 `ch:"count"`\n}\nif err := conn.QueryRow(context.Background(), "SELECT Col1, COUNT() AS count FROM example WHERE Col1 = 5 GROUP BY Col1").ScanStruct(&result); err != nil {\n    return err\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/scan_struct.go"},"Full Example")),(0,i.kt)("h3",{id:"append-struct"},"Append Struct"),(0,i.kt)("p",null,"AppendStruct allows a struct to be appended to an existing ",(0,i.kt)("a",{parentName:"p",href:"clickhouse-api#batch-insert"},"batch")," and interpreted as a complete row. This requires the columns of the struct to align in both name and type with the table. While all columns must have an equivalent struct field, some struct fields may not have an equivalent column representation. These will simply be ignored."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'batch, err := conn.PrepareBatch(context.Background(), "INSERT INTO example")\nif err != nil {\n    return err\n}\nfor i := 0; i < 1_000; i++ {\n    err := batch.AppendStruct(&row{\n        Col1:       uint64(i),\n        Col2:       "Golang SQL database driver",\n        Col3:       []uint8{1, 2, 3, 4, 5, 6, 7, 8, 9},\n        Col4:       time.Now(),\n        ColIgnored: "this will be ignored",\n    })\n    if err != nil {\n        return err\n    }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/append_struct.go"},"Full Example")),(0,i.kt)("h2",{id:"type-conversions"},"Type Conversions"),(0,i.kt)("p",null,"The client aims to be as flexible as possible concerning accepting variable types for both insertion and marshaling of responses. In most cases, an equivalent Golang type exists for a ClickHouse column type, e.g., ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/sql-reference/data-types/int-uint/"},"UInt64")," to ",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/builtin#uint64"},"uint64"),". These logical mappings should always be supported. Users may wish to utilize variable types that can be inserted into columns or used to receive a response if the conversion of either the variable or received data takes place first. The client aims to support these conversions transparently, so users do not need to convert their data to align precisely before insertion and to provide flexible marshaling at query time. This transparent conversion does not allow for precision loss. For example, a uint32 cannot be used to receive data from a UInt64 column. Conversely, a string can be inserted into a datetime64 field provided it meets the format requirements."),(0,i.kt)("p",null,"The type conversions currently supported for primitive types are captured ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/TYPES.md"},"here"),"."),(0,i.kt)("p",null,"This effort is ongoing and can be separated into insertion (",(0,i.kt)("inlineCode",{parentName:"p"},"Append"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"AppendRow"),") and read time (via a ",(0,i.kt)("inlineCode",{parentName:"p"},"Scan"),"). Should you need support for a specific conversion, please raise an issue."),(0,i.kt)("h2",{id:"complex-types"},"Complex Types"),(0,i.kt)("h3",{id:"datedatetime-types"},"Date/DateTime types"),(0,i.kt)("p",null,"The ClickHouse go client supports the ",(0,i.kt)("inlineCode",{parentName:"p"},"Date"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Date32"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTime"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"DateTime64")," date/datetime types. Dates can be inserted as a string in the format ",(0,i.kt)("inlineCode",{parentName:"p"},"2006-01-02")," or using the native go ",(0,i.kt)("inlineCode",{parentName:"p"},"time.Time{}")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"sql.NullTime"),". DateTimes also support the latter types but require strings to be passed in the format ",(0,i.kt)("inlineCode",{parentName:"p"},"2006-01-02 15:04:05")," with an optional timezone offset e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"2006-01-02 15:04:05 +08:00"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"time.Time{}")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sql.NullTime")," are both supported at read time as well as any implementation of of the ",(0,i.kt)("inlineCode",{parentName:"p"},"sql.Scanner")," interface."),(0,i.kt)("p",null,"Handling of timezone information depends on the ClickHouse type and whether the value is being inserted or read:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"DateTime/DateTime64"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"At ",(0,i.kt)("strong",{parentName:"li"},"insert")," time the value is sent to ClickHouse in UNIX timestamp format. If no time zone is provided, the client will assume the client's local time zone. ",(0,i.kt)("inlineCode",{parentName:"li"},"time.Time{}")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"sql.NullTime")," will be converted to epoch accordingly."),(0,i.kt)("li",{parentName:"ul"},"At ",(0,i.kt)("strong",{parentName:"li"},"select")," time the timezone of the column will be used if set when returning a ",(0,i.kt)("inlineCode",{parentName:"li"},"time.Time")," value. If not, the timezone of the server will be used."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Date/Date32"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"At ",(0,i.kt)("strong",{parentName:"li"},"insert")," time, the timezone of any date is considered when converting the date to a unix timestamp, i.e., it will be offset by the timezone prior to storage as a date, as Date types have no locale in ClickHouse. If this is not specified in a string value, the local timezone will be used."),(0,i.kt)("li",{parentName:"ul"},"At ",(0,i.kt)("strong",{parentName:"li"},"select")," time, dates are scanned into ",(0,i.kt)("inlineCode",{parentName:"li"},"time.Time{}")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"sql.NullTime{}")," instances will be returned without timezone information.")))),(0,i.kt)("h3",{id:"array"},"Array"),(0,i.kt)("p",null,"Arrays should be inserted as slices. Typing rules for the elements are consistent with those for the ",(0,i.kt)("a",{parentName:"p",href:"clickhouse-api#type-conversions"},"primitive type"),", i.e., where possible elements will be converted."),(0,i.kt)("p",null,"A pointer to a slice should be provided at Scan time."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'batch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\nvar i int64\nfor i = 0; i < 10; i++ {\n    err := batch.Append(\n        []string{strconv.Itoa(int(i)), strconv.Itoa(int(i + 1)), strconv.Itoa(int(i + 2)), strconv.Itoa(int(i + 3))},\n        [][]int64{{i, i + 1}, {i + 2, i + 3}, {i + 4, i + 5}},\n    )\n    if err != nil {\n        return err\n    }\n}\nif err := batch.Send(); err != nil {\n    return err\n}\nvar (\n    col1 []string\n    col2 [][]int64\n)\nrows, err := conn.Query(ctx, "SELECT * FROM example")\nif err != nil {\n    return err\n}\nfor rows.Next() {\n    if err := rows.Scan(&col1, &col2); err != nil {\n        return err\n    }\n    fmt.Printf("row: col1=%v, col2=%v\\n", col1, col2)\n}\nrows.Close()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/array.go"},"Full Example")),(0,i.kt)("h3",{id:"map"},"Map"),(0,i.kt)("p",null,"Maps should be inserted as Golang maps with keys and values conforming to the type rules defined ",(0,i.kt)("a",{parentName:"p",href:"clickhouse-api#type-conversions"},"earlier"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'batch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\nvar i int64\nfor i = 0; i < 10; i++ {\n    err := batch.Append(\n        map[string]uint64{strconv.Itoa(int(i)): uint64(i)},\n        map[string][]string{strconv.Itoa(int(i)): {strconv.Itoa(int(i)), strconv.Itoa(int(i + 1)), strconv.Itoa(int(i + 2)), strconv.Itoa(int(i + 3))}},\n        map[string]map[string]uint64{strconv.Itoa(int(i)): {strconv.Itoa(int(i)): uint64(i)}},\n    )\n    if err != nil {\n        return err\n    }\n}\nif err := batch.Send(); err != nil {\n    return err\n}\nvar (\n    col1 map[string]uint64\n    col2 map[string][]string\n    col3 map[string]map[string]uint64\n)\nrows, err := conn.Query(ctx, "SELECT * FROM example")\nif err != nil {\n    return err\n}\nfor rows.Next() {\n    if err := rows.Scan(&col1, &col2, &col3); err != nil {\n        return err\n    }\n    fmt.Printf("row: col1=%v, col2=%v, col3=%v\\n", col1, col2, col3)\n}\nrows.Close()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/map.go"},"Full Example")),(0,i.kt)("h3",{id:"tuples"},"Tuples"),(0,i.kt)("p",null,"Tuples represent a group of Columns of arbitrary length. The columns can either be explicitly named or only specify a type e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"//unnamed\nCol1 Tuple(String, Int64)\n\n//named\nCol2 Tuple(name String, id Int64, age uint8)\n")),(0,i.kt)("p",null,"Of these approaches, named tuples offer greater flexibility. While unnamed tuples must be inserted and read using slices, named tuples are also compatible with maps."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'if err = conn.Exec(ctx, `\n    CREATE TABLE example (\n            Col1 Tuple(name String, age UInt8),\n            Col2 Tuple(String, UInt8),\n            Col3 Tuple(name String, id String)\n        ) \n        Engine Memory\n    `); err != nil {\n    return err\n}\n\ndefer func() {\n    conn.Exec(ctx, "DROP TABLE example")\n}()\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\n// both named and unnamed can be added with slices. Note we can use strongly typed lists and maps if all elements are the same type\nif err = batch.Append([]interface{}{"Clicky McClickHouse", uint8(42)}, []interface{}{"Clicky McClickHouse Snr", uint8(78)}, []string{"Dale", "521211"}); err != nil {\n    return err\n}\nif err = batch.Append(map[string]interface{}{"name": "Clicky McClickHouse Jnr", "age": uint8(20)}, []interface{}{"Baby Clicky McClickHouse", uint8(1)}, map[string]string{"name": "Geoff", "id": "12123"}); err != nil {\n    return err\n}\nif err = batch.Send(); err != nil {\n    return err\n}\nvar (\n    col1 map[string]interface{}\n    col2 []interface{}\n    col3 map[string]string\n)\n// named tuples can be retrieved into a map or slices, unnamed just slices\nif err = conn.QueryRow(ctx, "SELECT * FROM example").Scan(&col1, &col2, &col3); err != nil {\n    return err\n}\nfmt.Printf("row: col1=%v, col2=%v, col3=%v\\n", col1, col2, col3)\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/tuple.go"},"Full Example")),(0,i.kt)("p",null,"Note: typed slices and maps are supported, provide the sub-columns in the named tuple are all of the same types. "),(0,i.kt)("h3",{id:"nested"},"Nested"),(0,i.kt)("p",null,"A Nested field is equivalent to an Array of named Tuples. Usage depends on whether the user has set ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/operations/settings/settings/#flatten-nested"},"flatten_nested")," to 1 or 0."),(0,i.kt)("p",null,"By setting flatten_nested to 0, Nested columns stay as a single array of tuples. This allows users to use slices of maps for insertion and retrieval and arbitrary levels of nesting. The map's key must equal the column's name, as shown in the example below."),(0,i.kt)("p",null,"Note: since the maps represent a tuple, they must be of the type ",(0,i.kt)("inlineCode",{parentName:"p"},"map[string]interface{}"),". The values are currently not strongly typed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := GetNativeConnection(clickhouse.Settings{\n    "flatten_nested": 0,\n}, nil, nil)\nif err != nil {\n    return err\n}\nctx := context.Background()\ndefer func() {\n    conn.Exec(ctx, "DROP TABLE example")\n}()\nconn.Exec(context.Background(), "DROP TABLE IF EXISTS example")\nerr = conn.Exec(ctx, `\n    CREATE TABLE example (\n        Col1 Nested(Col1_1 String, Col1_2 UInt8),\n        Col2 Nested(\n            Col2_1 UInt8, \n            Col2_2 Nested(\n                Col2_2_1 UInt8, \n                Col2_2_2 UInt8\n            )\n        )\n    ) Engine Memory\n`)\nif err != nil {\n    return err\n}\n\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\nvar i int64\nfor i = 0; i < 10; i++ {\n    err := batch.Append(\n        []map[string]interface{}{\n            {\n                "Col1_1": strconv.Itoa(int(i)),\n                "Col1_2": uint8(i),\n            },\n            {\n                "Col1_1": strconv.Itoa(int(i + 1)),\n                "Col1_2": uint8(i + 1),\n            },\n            {\n                "Col1_1": strconv.Itoa(int(i + 2)),\n                "Col1_2": uint8(i + 2),\n            },\n        },\n        []map[string]interface{}{\n            {\n                "Col2_2": []map[string]interface{}{\n                    {\n                        "Col2_2_1": uint8(i),\n                        "Col2_2_2": uint8(i + 1),\n                    },\n                },\n                "Col2_1": uint8(i),\n            },\n            {\n                "Col2_2": []map[string]interface{}{\n                    {\n                        "Col2_2_1": uint8(i + 2),\n                        "Col2_2_2": uint8(i + 3),\n                    },\n                },\n                "Col2_1": uint8(i + 1),\n            },\n        },\n    )\n    if err != nil {\n        return err\n    }\n}\nif err := batch.Send(); err != nil {\n    return err\n}\nvar (\n    col1 []map[string]interface{}\n    col2 []map[string]interface{}\n)\nrows, err := conn.Query(ctx, "SELECT * FROM example")\nif err != nil {\n    return err\n}\nfor rows.Next() {\n    if err := rows.Scan(&col1, &col2); err != nil {\n        return err\n    }\n    fmt.Printf("row: col1=%v, col2=%v\\n", col1, col2)\n}\nrows.Close()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/nested.go#L28-L118"},"Full Example - ",(0,i.kt)("inlineCode",{parentName:"a"},"flatten_tested=0"))),(0,i.kt)("p",null,"If the default value of 1 is used for ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten_nested"),", nested columns are flattened to separate arrays. This requires using nested slices for insertion and retrieval. While arbitrary levels of nesting may work, this is not officially supported. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := GetNativeConnection(nil, nil, nil)\nif err != nil {\n    return err\n}\nctx := context.Background()\ndefer func() {\n    conn.Exec(ctx, "DROP TABLE example")\n}()\nconn.Exec(ctx, "DROP TABLE IF EXISTS example")\nerr = conn.Exec(ctx, `\n    CREATE TABLE example (\n        Col1 Nested(Col1_1 String, Col1_2 UInt8),\n        Col2 Nested(\n            Col2_1 UInt8, \n            Col2_2 Nested(\n                Col2_2_1 UInt8, \n                Col2_2_2 UInt8\n            )\n        )\n    ) Engine Memory\n`)\nif err != nil {\n    return err\n}\n\n\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\nvar i uint8\nfor i = 0; i < 10; i++ {\n    col1_1_data := []string{strconv.Itoa(int(i)), strconv.Itoa(int(i + 1)), strconv.Itoa(int(i + 2))}\n    col1_2_data := []uint8{i, i + 1, i + 2}\n    col2_1_data := []uint8{i, i + 1, i + 2}\n    col2_2_data := [][][]interface{}{\n        {\n            {i, i + 1},\n        },\n        {\n            {i + 2, i + 3},\n        },\n        {\n            {i + 4, i + 5},\n        },\n    }\n    err := batch.Append(\n        col1_1_data,\n        col1_2_data,\n        col2_1_data,\n        col2_2_data,\n    )\n    if err != nil {\n        return err\n    }\n}\nif err := batch.Send(); err != nil {\n    return err\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/nested.go#L123-L180"},"Full Example - ",(0,i.kt)("inlineCode",{parentName:"a"},"flatten_nested=1"))),(0,i.kt)("p",null,"Note: Nested columns must have the same dimensions. For example, in the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Col_2_2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Col_2_1")," must have the same number of elements."),(0,i.kt)("p",null,"Due to a more straightforward interface and official support for nesting, we recommend ",(0,i.kt)("inlineCode",{parentName:"p"},"flatten_nested=0"),"."),(0,i.kt)("h3",{id:"json"},"JSON"),(0,i.kt)("p",null,"The JSON type utilizes schema inference to automatically create arbitrary levels of tuples, nested objects, and arrays in order to represent JSON data. Other than a root JSON column, the user does not need to define any column types - these will be automatically inferred from the data and created as required. For further details, see ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/guides/developer/working-with-json/json-semi-structured"},"Working with JSON"),". "),(0,i.kt)("p",null,"This feature is only available in versions later than 22.3. It represents the preferred mechanism for handling arbitrary semi-structured JSON. To provide maximum flexibility, the go client allows JSON to be inserted using a struct, map, or string. JSON columns can be marshaled back into either a struct or map. Examples of each approach are shown below."),(0,i.kt)("p",null,"Note the need to set ",(0,i.kt)("inlineCode",{parentName:"p"},"allow_experimental_object_type=1")," since JSON is experimental. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'if err = conn.Exec(ctx, `\n    CREATE TABLE example (\n            Col1 JSON,\n            Col2 JSON,\n            Col3 JSON\n        ) \n        Engine Memory\n    `); err != nil {\n    return err\n}\n\n\ntype User struct {\n    Name     string `json:"name"`\n    Age      uint8  `json:"age"`\n    Password string `ch:"-"`\n}\n\n\ndefer func() {\n    conn.Exec(ctx, "DROP TABLE example")\n}()\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\n// we can insert JSON as either a string, struct or map\ncol1Data := `{"name": "Clicky McClickHouse", "age": 40, "password": "password"}`\ncol2Data := User{\n    Name:     "Clicky McClickHouse Snr",\n    Age:      uint8(80),\n    Password: "random",\n}\ncol3Data := map[string]interface{}{\n    "name":     "Clicky McClickHouse Jnr",\n    "age":      uint8(10),\n    "password": "clicky",\n}\n// both named and unnamed can be added with slices\nif err = batch.Append(col1Data, col2Data, col3Data); err != nil {\n    return err\n}\n\nif err = batch.Send(); err != nil {\n    return err\n}\n// we can scan JSON into either a map or struct\nvar (\n    col1 map[string]interface{}\n    col2 map[string]interface{}\n    col3 User\n)\n// named tuples can be retrieved into a map or slices, unnamed just slices\nif err = conn.QueryRow(ctx, "SELECT * FROM example").Scan(&col1, &col2, &col3); err != nil {\n    return err\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/faef77ec2faf87667b2bd8f0bc930d1418f81f3e/examples/clickhouse_api/json.go#L43-L96"},"Full Example")),(0,i.kt)("p",null,"Maps can be strongly typed. Maps and structs can also be nested in any combination. See the more complex example ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/faef77ec2faf87667b2bd8f0bc930d1418f81f3e/examples/clickhouse_api/json.go#L102"},"here"),":"),(0,i.kt)("p",null,"If inserting structs, the client supports using ",(0,i.kt)("inlineCode",{parentName:"p"},"json")," tags to control the name of a field when serialized. Fields can also be ignored if using the special value of ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'type User struct {\n  Name     string `json:"name"`\n  Age      uint8  `json:"age"`\n  Password string `json:"-"`\n}\n')),(0,i.kt)("p",null,"The \u201cjson\u201d tag is respected by the standard ",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/encoding/json"},"golang json encoding")," package. The client also supports the \u201cch\u201d tag equivalent to \u201cjson\u201d. For example, the following is equivalent to the above for the client:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'type User struct {\n  Name     string `ch:"name"`\n  Age      uint8  `ch:"age"`\n  Password string `ch:"-"`\n}\n')),(0,i.kt)("h4",{id:"important-notes"},"Important Notes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"No current support for structs and maps which have pointers inside them. "),(0,i.kt)("li",{parentName:"ul"},"If inserting structs or maps, types must be consistent within a batch, i.e., a field must be consistent within a batch. Note that ClickHouse is able to downcast/coerce types, e.g., if a field is an int and then sent as a String, the field will be converted to a String - see ",(0,i.kt)("a",{parentName:"li",href:"https://clickhouse.com/docs/en/guides/developer/working-with-json/json-semi-structured#changing-columns"},"here")," for further examples. The client will not do this since it would require visibility of the complete dataset. If you need flexible types within a batch, insert the JSON as a string, e.g., you can't be sure if a JSON field is a string or number. This will defer type decisions and processing to the server."),(0,i.kt)("li",{parentName:"ul"},"Within a batch, we don't allow mixed formats for the same column e.g. strings with maps/structs. Maps and structs are equivalent and can be added to the same column. The examples above use strings for a different JSON column."),(0,i.kt)("li",{parentName:"ul"},"Dimensions and types within a slice must be the same e.g., an interface{} slice with a struct and list is not supported. This is the same behavior as ClickHouse, where lists of objects with different dimensions are not supported."),(0,i.kt)("li",{parentName:"ul"},"At query time, we do best-effort filling structs passed. Any data for which there is no field is currently ignored.")),(0,i.kt)("h3",{id:"geo-types"},"Geo Types"),(0,i.kt)("p",null,"The client supports the geo types Point, Ring, Polygon, and Multi Polygon. These fields are in Golang using the package ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/paulmach/orb"},"github.com/paulmach/orb"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'if err = conn.Exec(ctx, `\n    CREATE TABLE example (\n            point Point,\n            ring Ring,\n            polygon Polygon,\n            mPolygon MultiPolygon\n        ) \n        Engine Memory\n    `); err != nil {\n    return err\n}\n\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\n\nif err = batch.Append(\n    orb.Point{11, 22},\n    orb.Ring{\n        orb.Point{1, 2},\n        orb.Point{1, 2},\n    },\n    orb.Polygon{\n        orb.Ring{\n            orb.Point{1, 2},\n            orb.Point{12, 2},\n        },\n        orb.Ring{\n            orb.Point{11, 2},\n            orb.Point{1, 12},\n        },\n    },\n    orb.MultiPolygon{\n        orb.Polygon{\n            orb.Ring{\n                orb.Point{1, 2},\n                orb.Point{12, 2},\n            },\n            orb.Ring{\n                orb.Point{11, 2},\n                orb.Point{1, 12},\n            },\n        },\n        orb.Polygon{\n            orb.Ring{\n                orb.Point{1, 2},\n                orb.Point{12, 2},\n            },\n            orb.Ring{\n                orb.Point{11, 2},\n                orb.Point{1, 12},\n            },\n        },\n    },\n); err != nil {\n    return err\n}\n\nif err = batch.Send(); err != nil {\n    return err\n}\n\nvar (\n    point    orb.Point\n    ring     orb.Ring\n    polygon  orb.Polygon\n    mPolygon orb.MultiPolygon\n)\n\nif err = conn.QueryRow(ctx, "SELECT * FROM example").Scan(&point, &ring, &polygon, &mPolygon); err != nil {\n    return err\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/geo.go"},"Full Example")),(0,i.kt)("h3",{id:"uuid"},"UUID"),(0,i.kt)("p",null,"The UUID type is supported by the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/google/uuid"},"github.com/google/uuid")," package. Users can also send and marshall uuids as strings or any type which implements ",(0,i.kt)("inlineCode",{parentName:"p"},"sql.Scanner")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Stringify"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'if err = conn.Exec(ctx, `\n    CREATE TABLE example (\n            col1 UUID,\n            col2 UUID\n        ) \n        Engine Memory\n    `); err != nil {\n    return err\n}\n\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\ncol1Data, _ := uuid.NewUUID()\nif err = batch.Append(\n    col1Data,\n    "603966d6-ed93-11ec-8ea0-0242ac120002",\n); err != nil {\n    return err\n}\n\nif err = batch.Send(); err != nil {\n    return err\n}\n\nvar (\n    col1 uuid.UUID\n    col2 uuid.UUID\n)\n\nif err = conn.QueryRow(ctx, "SELECT * FROM example").Scan(&col1, &col2); err != nil {\n    return err\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/uuid.go"},"Full Example")),(0,i.kt)("h3",{id:"decimal"},"Decimal"),(0,i.kt)("p",null,"The Decimal type is supported by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/shopspring/decimal"},"github.com/shopspring/decimal")," package."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'if err = conn.Exec(ctx, `\n    CREATE TABLE example (\n        Col1 Decimal32(3), \n        Col2 Decimal(18,6), \n        Col3 Decimal(15,7), \n        Col4 Decimal128(8), \n        Col5 Decimal256(9)\n    ) Engine Memory\n    `); err != nil {\n    return err\n}\n\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\nif err = batch.Append(\n    decimal.New(25, 4),\n    decimal.New(30, 5),\n    decimal.New(35, 6),\n    decimal.New(135, 7),\n    decimal.New(256, 8),\n); err != nil {\n    return err\n}\n\nif err = batch.Send(); err != nil {\n    return err\n}\n\nvar (\n    col1 decimal.Decimal\n    col2 decimal.Decimal\n    col3 decimal.Decimal\n    col4 decimal.Decimal\n    col5 decimal.Decimal\n)\n\nif err = conn.QueryRow(ctx, "SELECT * FROM example").Scan(&col1, &col2, &col3, &col4, &col5); err != nil {\n    return err\n}\nfmt.Printf("col1=%v, col2=%v, col3=%v, col4=%v, col5=%v\\n", col1, col2, col3, col4, col5)\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/decimal.go"},"Full Example")),(0,i.kt)("h3",{id:"nullable"},"Nullable"),(0,i.kt)("p",null,"The go value of Nil represents a ClickHouse NULL. This can be used if a field is declared Nullable. At insert time, Nil can be passed for both the normal and Nullable version of a column. For the former, the default value for the type will be persisted, e.g., an empty string for string. For the nullable version, a NULL value will be stored in ClickHouse. "),(0,i.kt)("p",null,"At Scan time, the user must pass a pointer to a type that supports nil, e.g., *string, in order to represent the nil value for a Nullable field. In the example below, col1, which is a Nullable(String), thus receives a **string. This allows nil to be represented."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'if err = conn.Exec(ctx, `\n    CREATE TABLE example (\n            col1 Nullable(String),\n            col2 String,\n            col3 Nullable(Int8),\n            col4 Nullable(Int64)\n        ) \n        Engine Memory\n    `); err != nil {\n    return err\n}\n\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\nif err = batch.Append(\n    nil,\n    nil,\n    nil,\n    sql.NullInt64{Int64: 0, Valid: false},\n); err != nil {\n    return err\n}\n\nif err = batch.Send(); err != nil {\n    return err\n}\n\nvar (\n    col1 *string\n    col2 string\n    col3 *int8\n    col4 sql.NullInt64\n)\n\nif err = conn.QueryRow(ctx, "SELECT * FROM example").Scan(&col1, &col2, &col3, &col4); err != nil {\n    return err\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/nullable.go"},"Full Example")),(0,i.kt)("p",null,"The client additionally supports the ",(0,i.kt)("inlineCode",{parentName:"p"},"sql.Null*")," types e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"sql.NullInt64"),". These are compatible with their equivalent ClickHouse types."),(0,i.kt)("h3",{id:"big-ints----int128-int256-uint128-uint256"},"Big Ints -  Int128, Int256, UInt128, UInt256"),(0,i.kt)("p",null,"Number types larger than 64 bits are represented using the native go ",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/math/big"},"big")," package."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'if err = conn.Exec(ctx, `\n    CREATE TABLE example (\n        Col1 Int128, \n        Col2 UInt128, \n        Col3 Array(Int128), \n        Col4 Int256, \n        Col5 Array(Int256), \n        Col6 UInt256, \n        Col7 Array(UInt256)\n    ) Engine Memory`); err != nil {\n    return err\n}\n\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\n\ncol1Data, _ := new(big.Int).SetString("170141183460469231731687303715884105727", 10)\ncol2Data := big.NewInt(128)\ncol3Data := []*big.Int{\n    big.NewInt(-128),\n    big.NewInt(128128),\n    big.NewInt(128128128),\n}\ncol4Data := big.NewInt(256)\ncol5Data := []*big.Int{\n    big.NewInt(256),\n    big.NewInt(256256),\n    big.NewInt(256256256256),\n}\ncol6Data := big.NewInt(256)\ncol7Data := []*big.Int{\n    big.NewInt(256),\n    big.NewInt(256256),\n    big.NewInt(256256256256),\n}\n\nif err = batch.Append(col1Data, col2Data, col3Data, col4Data, col5Data, col6Data, col7Data); err != nil {\n    return err\n}\n\nif err = batch.Send(); err != nil {\n    return err\n}\n\nvar (\n    col1 big.Int\n    col2 big.Int\n    col3 []*big.Int\n    col4 big.Int\n    col5 []*big.Int\n    col6 big.Int\n    col7 []*big.Int\n)\n\nif err = conn.QueryRow(ctx, "SELECT * FROM example").Scan(&col1, &col2, &col3, &col4, &col5, &col6, &col7); err != nil {\n    return err\n}\nfmt.Printf("col1=%v, col2=%v, col3=%v, col4=%v, col5=%v, col6=%v, col7=%v\\n", col1, col2, col3, col4, col5, col6, col7)\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/big_int.go"},"Full Example")),(0,i.kt)("h2",{id:"compression"},"Compression"),(0,i.kt)("p",null,"Support for compression methods depends on the underlying protocol in use. For the native protocol, the client supports ",(0,i.kt)("inlineCode",{parentName:"p"},"LZ4")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ZSTD")," compression. This is performed at a block level only. Compression can be enabled by including a ",(0,i.kt)("inlineCode",{parentName:"p"},"Compression")," configuration with the connection."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'conn, err := clickhouse.Open(&clickhouse.Options{\n    Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.Port)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n    Compression: &clickhouse.Compression{\n        Method: clickhouse.CompressionZSTD,\n    },\n    MaxOpenConns: 1,\n})\nctx := context.Background()\ndefer func() {\n    conn.Exec(ctx, "DROP TABLE example")\n}()\nconn.Exec(context.Background(), "DROP TABLE IF EXISTS example")\nif err = conn.Exec(ctx, `\n    CREATE TABLE example (\n            Col1 Array(String)\n    ) Engine Memory\n    `); err != nil {\n    return err\n}\nbatch, err := conn.PrepareBatch(ctx, "INSERT INTO example")\nif err != nil {\n    return err\n}\nfor i := 0; i < 1000; i++ {\n    if err := batch.Append([]string{strconv.Itoa(i), strconv.Itoa(i + 1), strconv.Itoa(i + 2), strconv.Itoa(i + 3)}); err != nil {\n        return err\n    }\n}\nif err := batch.Send(); err != nil {\n    return err\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/compression.go"},"Full Example")),(0,i.kt)("p",null,"Additional compression techniques are available if using the standard interface over HTTP. See ",(0,i.kt)("a",{parentName:"p",href:"database-sql-api#compression"},"database/sql API - Compression")," for further details."),(0,i.kt)("h3",{id:"parameter-binding"},"Parameter Binding"),(0,i.kt)("p",null,"The client supports parameter binding for the Exec, Query, and QueryRow methods. As shown in the example below, this is supported using named, numbered, and positional parameters. We provide examples of these below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var count uint64\n// positional bind\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col1 >= ? AND Col3 < ?", 500, now.Add(time.Duration(750)*time.Second)).Scan(&count); err != nil {\n    return err\n}\n// 250\nfmt.Printf("Positional bind count: %d\\n", count)\n// numeric bind\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col1 <= $2 AND Col3 > $1", now.Add(time.Duration(150)*time.Second), 250).Scan(&count); err != nil {\n    return err\n}\n// 100\nfmt.Printf("Numeric bind count: %d\\n", count)\n// named bind\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col1 <= @col1 AND Col3 > @col3", clickhouse.Named("col1", 100), clickhouse.Named("col3", now.Add(time.Duration(50)*time.Second))).Scan(&count); err != nil {\n    return err\n}\n// 50\nfmt.Printf("Named bind count: %d\\n", count)\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/bind.go"},"Full Example")),(0,i.kt)("h3",{id:"special-cases"},"Special Cases"),(0,i.kt)("p",null,"By default, slices will be unfolded into a comma-separated list of values if passed as a parameter to a query. If users require a set of values to be injected with wrapping ",(0,i.kt)("inlineCode",{parentName:"p"},"[ ]"),", ArraySet should be used."),(0,i.kt)("p",null,"If groups/tuples are required, with wrapping ",(0,i.kt)("inlineCode",{parentName:"p"},"( )")," e.g., for use with IN operators, users can use a GroupSet. This is particularly useful for cases where multiple groups are required, as shown in the example below."),(0,i.kt)("p",null,"Finally, DateTime64 fields require precision in order to ensure parameters are rendered appropriately. The precision level for the field is unknown by the client, however, so the user must provide it. To facilitate this, we provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"DateNamed")," parameter."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var count uint64\n// arrays will be unfolded\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col1 IN (?)", []int{100, 200, 300, 400, 500}).Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("Array unfolded count: %d\\n", count)\n// arrays will be preserved with []\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col4 = ?", clickhouse.ArraySet{300, 301}).Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("Array count: %d\\n", count)\n// Group sets allow us to form ( ) lists\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col1 IN ?", clickhouse.GroupSet{[]interface{}{100, 200, 300, 400, 500}}).Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("Group count: %d\\n", count)\n// More useful when we need nesting\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE (Col1, Col5) IN (?)", []clickhouse.GroupSet{{[]interface{}{100, 101}}, {[]interface{}{200, 201}}}).Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("Group count: %d\\n", count)\n// Use DateNamed when you need a precision in your time#\nif err = conn.QueryRow(ctx, "SELECT count() FROM example WHERE Col3 >= @col3", clickhouse.DateNamed("col3", now.Add(time.Duration(500)*time.Millisecond), clickhouse.NanoSeconds)).Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("NamedDate count: %d\\n", count)\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/bind_special.go"},"Full Example")),(0,i.kt)("h2",{id:"using-context"},"Using Context"),(0,i.kt)("p",null,"Go contexts provide a means of passing deadlines, cancellation signals, and other request-scoped values across API boundaries. All methods on a connection accept a context as their first variable. While previous examples used context.Background(), users can use this capability to pass settings and deadlines and to cancel queries."),(0,i.kt)("p",null,"Passing a context created ",(0,i.kt)("inlineCode",{parentName:"p"},"withDeadline")," allows execution time limits to be placed on queries. Not this is an absolute time and expiry will only release the connection and send a cancel signal to ClickHouse. ",(0,i.kt)("inlineCode",{parentName:"p"},"WithCancel")," can alternatively be used to cancel a query explicitly."),(0,i.kt)("p",null,"The helpers  ",(0,i.kt)("inlineCode",{parentName:"p"},"clickhouse.WithQueryID")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"clickhouse.WithQuotaKey")," allow a query id and quota key to be specified. Query ids can be useful for tracking queries in logs and for cancellation purposes. A quota key can be used to impose limits on ClickHouse usage based on a unique key value - see ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/operations/access-rights#quotas-management"},"Quotas Management "),"for further details. "),(0,i.kt)("p",null,"Finally, users may wish to ensure a setting is only applied for a specific query - rather than for the entire connection, as shown in ",(0,i.kt)("a",{parentName:"p",href:"clickhouse-api#connection-settings"},"Connection Settings"),"."),(0,i.kt)("p",null,"Examples of the above are shown below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'dialCount := 0\nconn, err := clickhouse.Open(&clickhouse.Options{\n    Addr: []string{fmt.Sprintf("%s:%d", env.Host, env.Port)},\n    Auth: clickhouse.Auth{\n        Database: env.Database,\n        Username: env.Username,\n        Password: env.Password,\n    },\n    DialContext: func(ctx context.Context, addr string) (net.Conn, error) {\n        dialCount++\n        var d net.Dialer\n        return d.DialContext(ctx, "tcp", addr)\n    },\n})\nif err != nil {\n    return err\n}\nif err := clickhouse_tests.CheckMinServerServerVersion(conn, 22, 6, 1); err != nil {\n    return nil\n}\n// we can use context to pass settings to a specific API call\nctx := clickhouse.Context(context.Background(), clickhouse.WithSettings(clickhouse.Settings{\n    "allow_experimental_object_type": "1",\n}))\n\nconn.Exec(ctx, "DROP TABLE IF EXISTS example")\n\n// to create a JSON column we need allow_experimental_object_type=1\nif err = conn.Exec(ctx, `\n    CREATE TABLE example (\n            Col1 JSON\n        ) \n        Engine Memory\n    `); err != nil {\n    return err\n}\n\n// queries can be cancelled using the context\nctx, cancel := context.WithCancel(context.Background())\ngo func() {\n    cancel()\n}()\nif err = conn.QueryRow(ctx, "SELECT sleep(3)").Scan(); err == nil {\n    return fmt.Errorf("expected cancel")\n}\n\n// set a deadline for a query - this will cancel the query after the absolute time is reached.\n// queries will continue to completion in ClickHouse\nctx, cancel = context.WithDeadline(context.Background(), time.Now().Add(-time.Second))\ndefer cancel()\nif err := conn.Ping(ctx); err == nil {\n    return fmt.Errorf("expected deadline exceeeded")\n}\n\n// set a query id to assist tracing queries in logs e.g. see system.query_log\nvar one uint8\nqueryId, _ := uuid.NewUUID()\nctx = clickhouse.Context(context.Background(), clickhouse.WithQueryID(queryId.String()))\nif err = conn.QueryRow(ctx, "SELECT 1").Scan(&one); err != nil {\n    return err\n}\n\nconn.Exec(context.Background(), "DROP QUOTA IF EXISTS foobar")\ndefer func() {\n    conn.Exec(context.Background(), "DROP QUOTA IF EXISTS foobar")\n}()\nctx = clickhouse.Context(context.Background(), clickhouse.WithQuotaKey("abcde"))\n// set a quota key - first create the quota\nif err = conn.Exec(ctx, "CREATE QUOTA IF NOT EXISTS foobar KEYED BY client_key FOR INTERVAL 1 minute MAX queries = 5 TO default"); err != nil {\n    return err\n}\n\ntype Number struct {\n    Number uint64 `ch:"number"`\n}\nfor i := 1; i <= 6; i++ {\n    var result []Number\n    if err = conn.Select(ctx, &result, "SELECT number FROM numbers(10)"); err != nil {\n        return err\n    }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/context.go"},"Full Example")),(0,i.kt)("h2",{id:"progressprofilelog-information"},"Progress/Profile/Log Information"),(0,i.kt)("p",null,"Progress, Profile, and Log information can be requested on queries. Progress information will report statistics on the number of rows and bytes that have been read and processed in ClickHouse. Conversely, Profile information provides a summary of data returned to the client, including totals of bytes, rows, and blocks. Finally, log information provides statistics on threads, e.g., memory usage and data speed."),(0,i.kt)("p",null,"Obtaining this information requires the user to use ",(0,i.kt)("a",{parentName:"p",href:"clickhouse-api#using-context"},"Context"),", to which the user can pass call-back functions.  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'totalRows := uint64(0)\n// use context to pass a call back for progress and profile info\nctx := clickhouse.Context(context.Background(), clickhouse.WithProgress(func(p *clickhouse.Progress) {\n    fmt.Println("progress: ", p)\n    totalRows += p.Rows\n}), clickhouse.WithProfileInfo(func(p *clickhouse.ProfileInfo) {\n    fmt.Println("profile info: ", p)\n}), clickhouse.WithLogs(func(log *clickhouse.Log) {\n    fmt.Println("log info: ", log)\n}))\n\nrows, err := conn.Query(ctx, "SELECT number from numbers(1000000) LIMIT 1000000")\nif err != nil {\n    return err\n}\nfor rows.Next() {\n}\n\nfmt.Printf("Total Rows: %d\\n", totalRows)\nrows.Close()\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/progress.go"},"Full Example")),(0,i.kt)("h2",{id:"dynamic-scanning"},"Dynamic Scanning"),(0,i.kt)("p",null,"Users may need to read tables for which they do not know the schema or type of the fields being returned. This is common in cases where ad-hoc data analysis is performed or generic tooling is written. To achieve this, column-type information is available on query responses. This can be used with Go reflection to create runtime instances of correctly typed variables which can be passed to Scan."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"const query = `\nSELECT\n        1     AS Col1\n    , 'Text' AS Col2\n`\nrows, err := conn.Query(context.Background(), query)\nif err != nil {\n    return err\n}\nvar (\n    columnTypes = rows.ColumnTypes()\n    vars        = make([]interface{}, len(columnTypes))\n)\nfor i := range columnTypes {\n    vars[i] = reflect.New(columnTypes[i].ScanType()).Interface()\n}\nfor rows.Next() {\n    if err := rows.Scan(vars...); err != nil {\n        return err\n    }\n    for _, v := range vars {\n        switch v := v.(type) {\n        case *string:\n            fmt.Println(*v)\n        case *uint8:\n            fmt.Println(*v)\n        }\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/dynamic_scan_types.go"},"Full Example")),(0,i.kt)("h2",{id:"external-tables"},"External tables"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/engines/table-engines/special/external-data/"},"External tables")," allow the client to send data to ClickHouse, with a SELECT query. This data is put in a temporary table and can be used in the query itself for evaluation."),(0,i.kt)("p",null,"To send external data to the client with a query, the user must build an external table via ext.NewTable before passing this via the context."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'table1, err := ext.NewTable("external_table_1",\n    ext.Column("col1", "UInt8"),\n    ext.Column("col2", "String"),\n    ext.Column("col3", "DateTime"),\n)\nif err != nil {\n    return err\n}\n\nfor i := 0; i < 10; i++ {\n    if err = table1.Append(uint8(i), fmt.Sprintf("value_%d", i), time.Now()); err != nil {\n        return err\n    }\n}\n\ntable2, err := ext.NewTable("external_table_2",\n    ext.Column("col1", "UInt8"),\n    ext.Column("col2", "String"),\n    ext.Column("col3", "DateTime"),\n)\n\nfor i := 0; i < 10; i++ {\n    table2.Append(uint8(i), fmt.Sprintf("value_%d", i), time.Now())\n}\nctx := clickhouse.Context(context.Background(),\n    clickhouse.WithExternalTable(table1, table2),\n)\nrows, err := conn.Query(ctx, "SELECT * FROM external_table_1")\nif err != nil {\n    return err\n}\nfor rows.Next() {\n    var (\n        col1 uint8\n        col2 string\n        col3 time.Time\n    )\n    rows.Scan(&col1, &col2, &col3)\n    fmt.Printf("col1=%d, col2=%s, col3=%v\\n", col1, col2, col3)\n}\nrows.Close()\n\nvar count uint64\nif err := conn.QueryRow(ctx, "SELECT COUNT(*) FROM external_table_1").Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("external_table_1: %d\\n", count)\nif err := conn.QueryRow(ctx, "SELECT COUNT(*) FROM external_table_2").Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("external_table_2: %d\\n", count)\nif err := conn.QueryRow(ctx, "SELECT COUNT(*) FROM (SELECT * FROM external_table_1 UNION ALL SELECT * FROM external_table_2)").Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("external_table_1 UNION external_table_2: %d\\n", count)\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/external_data.go"},"Full Example")),(0,i.kt)("h2",{id:"open-telemetry"},"Open Telemetry"),(0,i.kt)("p",null,"ClickHouse allows a ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/operations/opentelemetry/"},"trace context")," to be passed as part of the native protocol. The client allows a Span to be created via the function ",(0,i.kt)("inlineCode",{parentName:"p"},"clickhouse.withSpan")," and passed via the Context to achieve this."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var count uint64\nrows := conn.QueryRow(clickhouse.Context(context.Background(), clickhouse.WithSpan(\n    trace.NewSpanContext(trace.SpanContextConfig{\n        SpanID:  trace.SpanID{1, 2, 3, 4, 5},\n        TraceID: trace.TraceID{5, 4, 3, 2, 1},\n    }),\n)), "SELECT COUNT() FROM (SELECT number FROM system.numbers LIMIT 5)")\nif err := rows.Scan(&count); err != nil {\n    return err\n}\nfmt.Printf("count: %d\\n", count)\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ClickHouse/clickhouse-go/blob/main/examples/clickhouse_api/open_telemetry.go"},"Full Example")),(0,i.kt)("p",null,"Full details on exploiting tracing can be found under ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/operations/opentelemetry/"},"OpenTelemetry support"),"."))}d.isMDXComponent=!0}}]);